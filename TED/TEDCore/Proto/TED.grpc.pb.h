// Generated by the gRPC C++ plugin.
// If you make any local change, they will be lost.
// source: TED.proto
#ifndef GRPC_TED_2eproto__INCLUDED
#define GRPC_TED_2eproto__INCLUDED

#include "TED.pb.h"

#include <functional>
#include <grpcpp/impl/codegen/async_generic_service.h>
#include <grpcpp/impl/codegen/async_stream.h>
#include <grpcpp/impl/codegen/async_unary_call.h>
#include <grpcpp/impl/codegen/client_callback.h>
#include <grpcpp/impl/codegen/client_context.h>
#include <grpcpp/impl/codegen/completion_queue.h>
#include <grpcpp/impl/codegen/message_allocator.h>
#include <grpcpp/impl/codegen/method_handler.h>
#include <grpcpp/impl/codegen/proto_utils.h>
#include <grpcpp/impl/codegen/rpc_method.h>
#include <grpcpp/impl/codegen/server_callback.h>
#include <grpcpp/impl/codegen/server_callback_handlers.h>
#include <grpcpp/impl/codegen/server_context.h>
#include <grpcpp/impl/codegen/service_type.h>
#include <grpcpp/impl/codegen/status.h>
#include <grpcpp/impl/codegen/stub_options.h>
#include <grpcpp/impl/codegen/sync_stream.h>

namespace TED {
namespace Grpc {

class TEDService final {
 public:
  static constexpr char const* service_full_name() {
    return "TED.Grpc.TEDService";
  }
  class StubInterface {
   public:
    virtual ~StubInterface() {}
    std::unique_ptr< ::grpc::ClientReaderInterface< ::TED::Grpc::BreakpointResponse>> GetBreakpoints(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReaderInterface< ::TED::Grpc::BreakpointResponse>>(GetBreakpointsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::TED::Grpc::BreakpointResponse>> AsyncGetBreakpoints(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::TED::Grpc::BreakpointResponse>>(AsyncGetBreakpointsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::TED::Grpc::BreakpointResponse>> PrepareAsyncGetBreakpoints(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReaderInterface< ::TED::Grpc::BreakpointResponse>>(PrepareAsyncGetBreakpointsRaw(context, request, cq));
    }
    virtual ::grpc::Status GetModules(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::TED::Grpc::GetModulesResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GetModulesResponse>> AsyncGetModules(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GetModulesResponse>>(AsyncGetModulesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GetModulesResponse>> PrepareAsyncGetModules(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GetModulesResponse>>(PrepareAsyncGetModulesRaw(context, request, cq));
    }
    virtual ::grpc::Status EnableBreakAllCallsInModule(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakAllCallsInModuleRequest& request, ::TED::Grpc::GenericResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> AsyncEnableBreakAllCallsInModule(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakAllCallsInModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(AsyncEnableBreakAllCallsInModuleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> PrepareAsyncEnableBreakAllCallsInModule(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakAllCallsInModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(PrepareAsyncEnableBreakAllCallsInModuleRaw(context, request, cq));
    }
    virtual ::grpc::Status DisableBreakAllCallsInModule(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakAllCallsInModuleRequest& request, ::TED::Grpc::GenericResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> AsyncDisableBreakAllCallsInModule(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakAllCallsInModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(AsyncDisableBreakAllCallsInModuleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> PrepareAsyncDisableBreakAllCallsInModule(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakAllCallsInModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(PrepareAsyncDisableBreakAllCallsInModuleRaw(context, request, cq));
    }
    virtual ::grpc::Status EnableBreakCallByAddress(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByAddressRequest& request, ::TED::Grpc::GenericResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> AsyncEnableBreakCallByAddress(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(AsyncEnableBreakCallByAddressRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> PrepareAsyncEnableBreakCallByAddress(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(PrepareAsyncEnableBreakCallByAddressRaw(context, request, cq));
    }
    virtual ::grpc::Status DisableBreakCallByAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByAddressRequest& request, ::TED::Grpc::GenericResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> AsyncDisableBreakCallByAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(AsyncDisableBreakCallByAddressRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> PrepareAsyncDisableBreakCallByAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(PrepareAsyncDisableBreakCallByAddressRaw(context, request, cq));
    }
    virtual ::grpc::Status EnableBreakCallByName(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByNameRequest& request, ::TED::Grpc::GenericResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> AsyncEnableBreakCallByName(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByNameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(AsyncEnableBreakCallByNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> PrepareAsyncEnableBreakCallByName(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByNameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(PrepareAsyncEnableBreakCallByNameRaw(context, request, cq));
    }
    virtual ::grpc::Status DisableBreakCallByName(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByNameRequest& request, ::TED::Grpc::GenericResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> AsyncDisableBreakCallByName(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByNameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(AsyncDisableBreakCallByNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> PrepareAsyncDisableBreakCallByName(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByNameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(PrepareAsyncDisableBreakCallByNameRaw(context, request, cq));
    }
    virtual ::grpc::Status EnableBreakpointByAddress(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByAddressRequest& request, ::TED::Grpc::GenericResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> AsyncEnableBreakpointByAddress(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(AsyncEnableBreakpointByAddressRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> PrepareAsyncEnableBreakpointByAddress(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(PrepareAsyncEnableBreakpointByAddressRaw(context, request, cq));
    }
    virtual ::grpc::Status DisableBreakpointByAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByAddressRequest& request, ::TED::Grpc::GenericResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> AsyncDisableBreakpointByAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(AsyncDisableBreakpointByAddressRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> PrepareAsyncDisableBreakpointByAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(PrepareAsyncDisableBreakpointByAddressRaw(context, request, cq));
    }
    virtual ::grpc::Status EnableBreakpointByName(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByNameRequest& request, ::TED::Grpc::GenericResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> AsyncEnableBreakpointByName(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByNameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(AsyncEnableBreakpointByNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> PrepareAsyncEnableBreakpointByName(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByNameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(PrepareAsyncEnableBreakpointByNameRaw(context, request, cq));
    }
    virtual ::grpc::Status DisableBreakpointByName(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByNameRequest& request, ::TED::Grpc::GenericResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> AsyncDisableBreakpointByName(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByNameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(AsyncDisableBreakpointByNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> PrepareAsyncDisableBreakpointByName(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByNameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(PrepareAsyncDisableBreakpointByNameRaw(context, request, cq));
    }
    virtual ::grpc::Status DisassembleAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisassembleAddressRequest& request, ::TED::Grpc::DisassembleAddressResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::DisassembleAddressResponse>> AsyncDisassembleAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisassembleAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::DisassembleAddressResponse>>(AsyncDisassembleAddressRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::DisassembleAddressResponse>> PrepareAsyncDisassembleAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisassembleAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::DisassembleAddressResponse>>(PrepareAsyncDisassembleAddressRaw(context, request, cq));
    }
    virtual ::grpc::Status LoadModule(::grpc::ClientContext* context, const ::TED::Grpc::LoadModuleRequest& request, ::TED::Grpc::GenericResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> AsyncLoadModule(::grpc::ClientContext* context, const ::TED::Grpc::LoadModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(AsyncLoadModuleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> PrepareAsyncLoadModule(::grpc::ClientContext* context, const ::TED::Grpc::LoadModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(PrepareAsyncLoadModuleRaw(context, request, cq));
    }
    virtual ::grpc::Status UnloadModule(::grpc::ClientContext* context, const ::TED::Grpc::UnloadModuleRequest& request, ::TED::Grpc::GenericResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> AsyncUnloadModule(::grpc::ClientContext* context, const ::TED::Grpc::UnloadModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(AsyncUnloadModuleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> PrepareAsyncUnloadModule(::grpc::ClientContext* context, const ::TED::Grpc::UnloadModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(PrepareAsyncUnloadModuleRaw(context, request, cq));
    }
    virtual ::grpc::Status ReadMemory(::grpc::ClientContext* context, const ::TED::Grpc::ReadMemoryRequest& request, ::TED::Grpc::ReadMemoryResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::ReadMemoryResponse>> AsyncReadMemory(::grpc::ClientContext* context, const ::TED::Grpc::ReadMemoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::ReadMemoryResponse>>(AsyncReadMemoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::ReadMemoryResponse>> PrepareAsyncReadMemory(::grpc::ClientContext* context, const ::TED::Grpc::ReadMemoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::ReadMemoryResponse>>(PrepareAsyncReadMemoryRaw(context, request, cq));
    }
    virtual ::grpc::Status WriteMemory(::grpc::ClientContext* context, const ::TED::Grpc::WriteMemoryRequest& request, ::TED::Grpc::GenericResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> AsyncWriteMemory(::grpc::ClientContext* context, const ::TED::Grpc::WriteMemoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(AsyncWriteMemoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> PrepareAsyncWriteMemory(::grpc::ClientContext* context, const ::TED::Grpc::WriteMemoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(PrepareAsyncWriteMemoryRaw(context, request, cq));
    }
    virtual ::grpc::Status CreateConsole(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::TED::Grpc::GenericResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> AsyncCreateConsole(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(AsyncCreateConsoleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> PrepareAsyncCreateConsole(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(PrepareAsyncCreateConsoleRaw(context, request, cq));
    }
    virtual ::grpc::Status DestroyConsole(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::TED::Grpc::GenericResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> AsyncDestroyConsole(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(AsyncDestroyConsoleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> PrepareAsyncDestroyConsole(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(PrepareAsyncDestroyConsoleRaw(context, request, cq));
    }
    virtual ::grpc::Status EnableInternalLogging(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::TED::Grpc::GenericResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> AsyncEnableInternalLogging(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(AsyncEnableInternalLoggingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> PrepareAsyncEnableInternalLogging(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(PrepareAsyncEnableInternalLoggingRaw(context, request, cq));
    }
    virtual ::grpc::Status DisableInternalLogging(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::TED::Grpc::GenericResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> AsyncDisableInternalLogging(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(AsyncDisableInternalLoggingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> PrepareAsyncDisableInternalLogging(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(PrepareAsyncDisableInternalLoggingRaw(context, request, cq));
    }
    virtual ::grpc::Status Options(::grpc::ClientContext* context, const ::TED::Grpc::OptionsRequest& request, ::TED::Grpc::GenericResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> AsyncOptions(::grpc::ClientContext* context, const ::TED::Grpc::OptionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(AsyncOptionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> PrepareAsyncOptions(::grpc::ClientContext* context, const ::TED::Grpc::OptionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(PrepareAsyncOptionsRaw(context, request, cq));
    }
    virtual ::grpc::Status TestFunction(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::TED::Grpc::GenericResponse* response) = 0;
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> AsyncTestFunction(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(AsyncTestFunctionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>> PrepareAsyncTestFunction(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>>(PrepareAsyncTestFunctionRaw(context, request, cq));
    }
    class async_interface {
     public:
      virtual ~async_interface() {}
      virtual void GetBreakpoints(::grpc::ClientContext* context, const ::TED::Grpc::Empty* request, ::grpc::ClientReadReactor< ::TED::Grpc::BreakpointResponse>* reactor) = 0;
      virtual void GetModules(::grpc::ClientContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GetModulesResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void GetModules(::grpc::ClientContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GetModulesResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void EnableBreakAllCallsInModule(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakAllCallsInModuleRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void EnableBreakAllCallsInModule(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakAllCallsInModuleRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void DisableBreakAllCallsInModule(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakAllCallsInModuleRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DisableBreakAllCallsInModule(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakAllCallsInModuleRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void EnableBreakCallByAddress(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByAddressRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void EnableBreakCallByAddress(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByAddressRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void DisableBreakCallByAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByAddressRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DisableBreakCallByAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByAddressRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void EnableBreakCallByName(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByNameRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void EnableBreakCallByName(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByNameRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void DisableBreakCallByName(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByNameRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DisableBreakCallByName(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByNameRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void EnableBreakpointByAddress(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByAddressRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void EnableBreakpointByAddress(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByAddressRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void DisableBreakpointByAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByAddressRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DisableBreakpointByAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByAddressRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void EnableBreakpointByName(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByNameRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void EnableBreakpointByName(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByNameRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void DisableBreakpointByName(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByNameRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DisableBreakpointByName(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByNameRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void DisassembleAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisassembleAddressRequest* request, ::TED::Grpc::DisassembleAddressResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DisassembleAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisassembleAddressRequest* request, ::TED::Grpc::DisassembleAddressResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void LoadModule(::grpc::ClientContext* context, const ::TED::Grpc::LoadModuleRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void LoadModule(::grpc::ClientContext* context, const ::TED::Grpc::LoadModuleRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void UnloadModule(::grpc::ClientContext* context, const ::TED::Grpc::UnloadModuleRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void UnloadModule(::grpc::ClientContext* context, const ::TED::Grpc::UnloadModuleRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void ReadMemory(::grpc::ClientContext* context, const ::TED::Grpc::ReadMemoryRequest* request, ::TED::Grpc::ReadMemoryResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void ReadMemory(::grpc::ClientContext* context, const ::TED::Grpc::ReadMemoryRequest* request, ::TED::Grpc::ReadMemoryResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void WriteMemory(::grpc::ClientContext* context, const ::TED::Grpc::WriteMemoryRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void WriteMemory(::grpc::ClientContext* context, const ::TED::Grpc::WriteMemoryRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void CreateConsole(::grpc::ClientContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void CreateConsole(::grpc::ClientContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void DestroyConsole(::grpc::ClientContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DestroyConsole(::grpc::ClientContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void EnableInternalLogging(::grpc::ClientContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void EnableInternalLogging(::grpc::ClientContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void DisableInternalLogging(::grpc::ClientContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void DisableInternalLogging(::grpc::ClientContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void Options(::grpc::ClientContext* context, const ::TED::Grpc::OptionsRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void Options(::grpc::ClientContext* context, const ::TED::Grpc::OptionsRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
      virtual void TestFunction(::grpc::ClientContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) = 0;
      virtual void TestFunction(::grpc::ClientContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) = 0;
    };
    typedef class async_interface experimental_async_interface;
    virtual class async_interface* async() { return nullptr; }
    class async_interface* experimental_async() { return async(); }
   private:
    virtual ::grpc::ClientReaderInterface< ::TED::Grpc::BreakpointResponse>* GetBreakpointsRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::TED::Grpc::BreakpointResponse>* AsyncGetBreakpointsRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq, void* tag) = 0;
    virtual ::grpc::ClientAsyncReaderInterface< ::TED::Grpc::BreakpointResponse>* PrepareAsyncGetBreakpointsRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GetModulesResponse>* AsyncGetModulesRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GetModulesResponse>* PrepareAsyncGetModulesRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* AsyncEnableBreakAllCallsInModuleRaw(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakAllCallsInModuleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* PrepareAsyncEnableBreakAllCallsInModuleRaw(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakAllCallsInModuleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* AsyncDisableBreakAllCallsInModuleRaw(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakAllCallsInModuleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* PrepareAsyncDisableBreakAllCallsInModuleRaw(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakAllCallsInModuleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* AsyncEnableBreakCallByAddressRaw(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByAddressRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* PrepareAsyncEnableBreakCallByAddressRaw(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByAddressRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* AsyncDisableBreakCallByAddressRaw(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByAddressRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* PrepareAsyncDisableBreakCallByAddressRaw(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByAddressRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* AsyncEnableBreakCallByNameRaw(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByNameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* PrepareAsyncEnableBreakCallByNameRaw(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByNameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* AsyncDisableBreakCallByNameRaw(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByNameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* PrepareAsyncDisableBreakCallByNameRaw(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByNameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* AsyncEnableBreakpointByAddressRaw(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByAddressRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* PrepareAsyncEnableBreakpointByAddressRaw(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByAddressRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* AsyncDisableBreakpointByAddressRaw(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByAddressRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* PrepareAsyncDisableBreakpointByAddressRaw(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByAddressRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* AsyncEnableBreakpointByNameRaw(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByNameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* PrepareAsyncEnableBreakpointByNameRaw(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByNameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* AsyncDisableBreakpointByNameRaw(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByNameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* PrepareAsyncDisableBreakpointByNameRaw(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByNameRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::DisassembleAddressResponse>* AsyncDisassembleAddressRaw(::grpc::ClientContext* context, const ::TED::Grpc::DisassembleAddressRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::DisassembleAddressResponse>* PrepareAsyncDisassembleAddressRaw(::grpc::ClientContext* context, const ::TED::Grpc::DisassembleAddressRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* AsyncLoadModuleRaw(::grpc::ClientContext* context, const ::TED::Grpc::LoadModuleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* PrepareAsyncLoadModuleRaw(::grpc::ClientContext* context, const ::TED::Grpc::LoadModuleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* AsyncUnloadModuleRaw(::grpc::ClientContext* context, const ::TED::Grpc::UnloadModuleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* PrepareAsyncUnloadModuleRaw(::grpc::ClientContext* context, const ::TED::Grpc::UnloadModuleRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::ReadMemoryResponse>* AsyncReadMemoryRaw(::grpc::ClientContext* context, const ::TED::Grpc::ReadMemoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::ReadMemoryResponse>* PrepareAsyncReadMemoryRaw(::grpc::ClientContext* context, const ::TED::Grpc::ReadMemoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* AsyncWriteMemoryRaw(::grpc::ClientContext* context, const ::TED::Grpc::WriteMemoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* PrepareAsyncWriteMemoryRaw(::grpc::ClientContext* context, const ::TED::Grpc::WriteMemoryRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* AsyncCreateConsoleRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* PrepareAsyncCreateConsoleRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* AsyncDestroyConsoleRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* PrepareAsyncDestroyConsoleRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* AsyncEnableInternalLoggingRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* PrepareAsyncEnableInternalLoggingRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* AsyncDisableInternalLoggingRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* PrepareAsyncDisableInternalLoggingRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* AsyncOptionsRaw(::grpc::ClientContext* context, const ::TED::Grpc::OptionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* PrepareAsyncOptionsRaw(::grpc::ClientContext* context, const ::TED::Grpc::OptionsRequest& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* AsyncTestFunctionRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) = 0;
    virtual ::grpc::ClientAsyncResponseReaderInterface< ::TED::Grpc::GenericResponse>* PrepareAsyncTestFunctionRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) = 0;
  };
  class Stub final : public StubInterface {
   public:
    Stub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());
    std::unique_ptr< ::grpc::ClientReader< ::TED::Grpc::BreakpointResponse>> GetBreakpoints(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request) {
      return std::unique_ptr< ::grpc::ClientReader< ::TED::Grpc::BreakpointResponse>>(GetBreakpointsRaw(context, request));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::TED::Grpc::BreakpointResponse>> AsyncGetBreakpoints(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq, void* tag) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::TED::Grpc::BreakpointResponse>>(AsyncGetBreakpointsRaw(context, request, cq, tag));
    }
    std::unique_ptr< ::grpc::ClientAsyncReader< ::TED::Grpc::BreakpointResponse>> PrepareAsyncGetBreakpoints(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncReader< ::TED::Grpc::BreakpointResponse>>(PrepareAsyncGetBreakpointsRaw(context, request, cq));
    }
    ::grpc::Status GetModules(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::TED::Grpc::GetModulesResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GetModulesResponse>> AsyncGetModules(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GetModulesResponse>>(AsyncGetModulesRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GetModulesResponse>> PrepareAsyncGetModules(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GetModulesResponse>>(PrepareAsyncGetModulesRaw(context, request, cq));
    }
    ::grpc::Status EnableBreakAllCallsInModule(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakAllCallsInModuleRequest& request, ::TED::Grpc::GenericResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> AsyncEnableBreakAllCallsInModule(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakAllCallsInModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(AsyncEnableBreakAllCallsInModuleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> PrepareAsyncEnableBreakAllCallsInModule(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakAllCallsInModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(PrepareAsyncEnableBreakAllCallsInModuleRaw(context, request, cq));
    }
    ::grpc::Status DisableBreakAllCallsInModule(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakAllCallsInModuleRequest& request, ::TED::Grpc::GenericResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> AsyncDisableBreakAllCallsInModule(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakAllCallsInModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(AsyncDisableBreakAllCallsInModuleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> PrepareAsyncDisableBreakAllCallsInModule(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakAllCallsInModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(PrepareAsyncDisableBreakAllCallsInModuleRaw(context, request, cq));
    }
    ::grpc::Status EnableBreakCallByAddress(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByAddressRequest& request, ::TED::Grpc::GenericResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> AsyncEnableBreakCallByAddress(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(AsyncEnableBreakCallByAddressRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> PrepareAsyncEnableBreakCallByAddress(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(PrepareAsyncEnableBreakCallByAddressRaw(context, request, cq));
    }
    ::grpc::Status DisableBreakCallByAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByAddressRequest& request, ::TED::Grpc::GenericResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> AsyncDisableBreakCallByAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(AsyncDisableBreakCallByAddressRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> PrepareAsyncDisableBreakCallByAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(PrepareAsyncDisableBreakCallByAddressRaw(context, request, cq));
    }
    ::grpc::Status EnableBreakCallByName(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByNameRequest& request, ::TED::Grpc::GenericResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> AsyncEnableBreakCallByName(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByNameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(AsyncEnableBreakCallByNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> PrepareAsyncEnableBreakCallByName(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByNameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(PrepareAsyncEnableBreakCallByNameRaw(context, request, cq));
    }
    ::grpc::Status DisableBreakCallByName(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByNameRequest& request, ::TED::Grpc::GenericResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> AsyncDisableBreakCallByName(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByNameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(AsyncDisableBreakCallByNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> PrepareAsyncDisableBreakCallByName(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByNameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(PrepareAsyncDisableBreakCallByNameRaw(context, request, cq));
    }
    ::grpc::Status EnableBreakpointByAddress(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByAddressRequest& request, ::TED::Grpc::GenericResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> AsyncEnableBreakpointByAddress(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(AsyncEnableBreakpointByAddressRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> PrepareAsyncEnableBreakpointByAddress(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(PrepareAsyncEnableBreakpointByAddressRaw(context, request, cq));
    }
    ::grpc::Status DisableBreakpointByAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByAddressRequest& request, ::TED::Grpc::GenericResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> AsyncDisableBreakpointByAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(AsyncDisableBreakpointByAddressRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> PrepareAsyncDisableBreakpointByAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(PrepareAsyncDisableBreakpointByAddressRaw(context, request, cq));
    }
    ::grpc::Status EnableBreakpointByName(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByNameRequest& request, ::TED::Grpc::GenericResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> AsyncEnableBreakpointByName(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByNameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(AsyncEnableBreakpointByNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> PrepareAsyncEnableBreakpointByName(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByNameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(PrepareAsyncEnableBreakpointByNameRaw(context, request, cq));
    }
    ::grpc::Status DisableBreakpointByName(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByNameRequest& request, ::TED::Grpc::GenericResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> AsyncDisableBreakpointByName(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByNameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(AsyncDisableBreakpointByNameRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> PrepareAsyncDisableBreakpointByName(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByNameRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(PrepareAsyncDisableBreakpointByNameRaw(context, request, cq));
    }
    ::grpc::Status DisassembleAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisassembleAddressRequest& request, ::TED::Grpc::DisassembleAddressResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::DisassembleAddressResponse>> AsyncDisassembleAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisassembleAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::DisassembleAddressResponse>>(AsyncDisassembleAddressRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::DisassembleAddressResponse>> PrepareAsyncDisassembleAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisassembleAddressRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::DisassembleAddressResponse>>(PrepareAsyncDisassembleAddressRaw(context, request, cq));
    }
    ::grpc::Status LoadModule(::grpc::ClientContext* context, const ::TED::Grpc::LoadModuleRequest& request, ::TED::Grpc::GenericResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> AsyncLoadModule(::grpc::ClientContext* context, const ::TED::Grpc::LoadModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(AsyncLoadModuleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> PrepareAsyncLoadModule(::grpc::ClientContext* context, const ::TED::Grpc::LoadModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(PrepareAsyncLoadModuleRaw(context, request, cq));
    }
    ::grpc::Status UnloadModule(::grpc::ClientContext* context, const ::TED::Grpc::UnloadModuleRequest& request, ::TED::Grpc::GenericResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> AsyncUnloadModule(::grpc::ClientContext* context, const ::TED::Grpc::UnloadModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(AsyncUnloadModuleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> PrepareAsyncUnloadModule(::grpc::ClientContext* context, const ::TED::Grpc::UnloadModuleRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(PrepareAsyncUnloadModuleRaw(context, request, cq));
    }
    ::grpc::Status ReadMemory(::grpc::ClientContext* context, const ::TED::Grpc::ReadMemoryRequest& request, ::TED::Grpc::ReadMemoryResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::ReadMemoryResponse>> AsyncReadMemory(::grpc::ClientContext* context, const ::TED::Grpc::ReadMemoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::ReadMemoryResponse>>(AsyncReadMemoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::ReadMemoryResponse>> PrepareAsyncReadMemory(::grpc::ClientContext* context, const ::TED::Grpc::ReadMemoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::ReadMemoryResponse>>(PrepareAsyncReadMemoryRaw(context, request, cq));
    }
    ::grpc::Status WriteMemory(::grpc::ClientContext* context, const ::TED::Grpc::WriteMemoryRequest& request, ::TED::Grpc::GenericResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> AsyncWriteMemory(::grpc::ClientContext* context, const ::TED::Grpc::WriteMemoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(AsyncWriteMemoryRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> PrepareAsyncWriteMemory(::grpc::ClientContext* context, const ::TED::Grpc::WriteMemoryRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(PrepareAsyncWriteMemoryRaw(context, request, cq));
    }
    ::grpc::Status CreateConsole(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::TED::Grpc::GenericResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> AsyncCreateConsole(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(AsyncCreateConsoleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> PrepareAsyncCreateConsole(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(PrepareAsyncCreateConsoleRaw(context, request, cq));
    }
    ::grpc::Status DestroyConsole(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::TED::Grpc::GenericResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> AsyncDestroyConsole(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(AsyncDestroyConsoleRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> PrepareAsyncDestroyConsole(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(PrepareAsyncDestroyConsoleRaw(context, request, cq));
    }
    ::grpc::Status EnableInternalLogging(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::TED::Grpc::GenericResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> AsyncEnableInternalLogging(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(AsyncEnableInternalLoggingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> PrepareAsyncEnableInternalLogging(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(PrepareAsyncEnableInternalLoggingRaw(context, request, cq));
    }
    ::grpc::Status DisableInternalLogging(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::TED::Grpc::GenericResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> AsyncDisableInternalLogging(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(AsyncDisableInternalLoggingRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> PrepareAsyncDisableInternalLogging(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(PrepareAsyncDisableInternalLoggingRaw(context, request, cq));
    }
    ::grpc::Status Options(::grpc::ClientContext* context, const ::TED::Grpc::OptionsRequest& request, ::TED::Grpc::GenericResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> AsyncOptions(::grpc::ClientContext* context, const ::TED::Grpc::OptionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(AsyncOptionsRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> PrepareAsyncOptions(::grpc::ClientContext* context, const ::TED::Grpc::OptionsRequest& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(PrepareAsyncOptionsRaw(context, request, cq));
    }
    ::grpc::Status TestFunction(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::TED::Grpc::GenericResponse* response) override;
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> AsyncTestFunction(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(AsyncTestFunctionRaw(context, request, cq));
    }
    std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>> PrepareAsyncTestFunction(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) {
      return std::unique_ptr< ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>>(PrepareAsyncTestFunctionRaw(context, request, cq));
    }
    class async final :
      public StubInterface::async_interface {
     public:
      void GetBreakpoints(::grpc::ClientContext* context, const ::TED::Grpc::Empty* request, ::grpc::ClientReadReactor< ::TED::Grpc::BreakpointResponse>* reactor) override;
      void GetModules(::grpc::ClientContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GetModulesResponse* response, std::function<void(::grpc::Status)>) override;
      void GetModules(::grpc::ClientContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GetModulesResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void EnableBreakAllCallsInModule(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakAllCallsInModuleRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) override;
      void EnableBreakAllCallsInModule(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakAllCallsInModuleRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DisableBreakAllCallsInModule(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakAllCallsInModuleRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) override;
      void DisableBreakAllCallsInModule(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakAllCallsInModuleRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void EnableBreakCallByAddress(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByAddressRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) override;
      void EnableBreakCallByAddress(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByAddressRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DisableBreakCallByAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByAddressRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) override;
      void DisableBreakCallByAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByAddressRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void EnableBreakCallByName(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByNameRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) override;
      void EnableBreakCallByName(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByNameRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DisableBreakCallByName(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByNameRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) override;
      void DisableBreakCallByName(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByNameRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void EnableBreakpointByAddress(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByAddressRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) override;
      void EnableBreakpointByAddress(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByAddressRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DisableBreakpointByAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByAddressRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) override;
      void DisableBreakpointByAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByAddressRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void EnableBreakpointByName(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByNameRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) override;
      void EnableBreakpointByName(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByNameRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DisableBreakpointByName(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByNameRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) override;
      void DisableBreakpointByName(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByNameRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DisassembleAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisassembleAddressRequest* request, ::TED::Grpc::DisassembleAddressResponse* response, std::function<void(::grpc::Status)>) override;
      void DisassembleAddress(::grpc::ClientContext* context, const ::TED::Grpc::DisassembleAddressRequest* request, ::TED::Grpc::DisassembleAddressResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void LoadModule(::grpc::ClientContext* context, const ::TED::Grpc::LoadModuleRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) override;
      void LoadModule(::grpc::ClientContext* context, const ::TED::Grpc::LoadModuleRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void UnloadModule(::grpc::ClientContext* context, const ::TED::Grpc::UnloadModuleRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) override;
      void UnloadModule(::grpc::ClientContext* context, const ::TED::Grpc::UnloadModuleRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void ReadMemory(::grpc::ClientContext* context, const ::TED::Grpc::ReadMemoryRequest* request, ::TED::Grpc::ReadMemoryResponse* response, std::function<void(::grpc::Status)>) override;
      void ReadMemory(::grpc::ClientContext* context, const ::TED::Grpc::ReadMemoryRequest* request, ::TED::Grpc::ReadMemoryResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void WriteMemory(::grpc::ClientContext* context, const ::TED::Grpc::WriteMemoryRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) override;
      void WriteMemory(::grpc::ClientContext* context, const ::TED::Grpc::WriteMemoryRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void CreateConsole(::grpc::ClientContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) override;
      void CreateConsole(::grpc::ClientContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DestroyConsole(::grpc::ClientContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) override;
      void DestroyConsole(::grpc::ClientContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void EnableInternalLogging(::grpc::ClientContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) override;
      void EnableInternalLogging(::grpc::ClientContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void DisableInternalLogging(::grpc::ClientContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) override;
      void DisableInternalLogging(::grpc::ClientContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void Options(::grpc::ClientContext* context, const ::TED::Grpc::OptionsRequest* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) override;
      void Options(::grpc::ClientContext* context, const ::TED::Grpc::OptionsRequest* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
      void TestFunction(::grpc::ClientContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response, std::function<void(::grpc::Status)>) override;
      void TestFunction(::grpc::ClientContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response, ::grpc::ClientUnaryReactor* reactor) override;
     private:
      friend class Stub;
      explicit async(Stub* stub): stub_(stub) { }
      Stub* stub() { return stub_; }
      Stub* stub_;
    };
    class async* async() override { return &async_stub_; }

   private:
    std::shared_ptr< ::grpc::ChannelInterface> channel_;
    class async async_stub_{this};
    ::grpc::ClientReader< ::TED::Grpc::BreakpointResponse>* GetBreakpointsRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request) override;
    ::grpc::ClientAsyncReader< ::TED::Grpc::BreakpointResponse>* AsyncGetBreakpointsRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq, void* tag) override;
    ::grpc::ClientAsyncReader< ::TED::Grpc::BreakpointResponse>* PrepareAsyncGetBreakpointsRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GetModulesResponse>* AsyncGetModulesRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GetModulesResponse>* PrepareAsyncGetModulesRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* AsyncEnableBreakAllCallsInModuleRaw(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakAllCallsInModuleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* PrepareAsyncEnableBreakAllCallsInModuleRaw(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakAllCallsInModuleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* AsyncDisableBreakAllCallsInModuleRaw(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakAllCallsInModuleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* PrepareAsyncDisableBreakAllCallsInModuleRaw(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakAllCallsInModuleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* AsyncEnableBreakCallByAddressRaw(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByAddressRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* PrepareAsyncEnableBreakCallByAddressRaw(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByAddressRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* AsyncDisableBreakCallByAddressRaw(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByAddressRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* PrepareAsyncDisableBreakCallByAddressRaw(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByAddressRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* AsyncEnableBreakCallByNameRaw(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByNameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* PrepareAsyncEnableBreakCallByNameRaw(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakCallByNameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* AsyncDisableBreakCallByNameRaw(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByNameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* PrepareAsyncDisableBreakCallByNameRaw(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakCallByNameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* AsyncEnableBreakpointByAddressRaw(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByAddressRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* PrepareAsyncEnableBreakpointByAddressRaw(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByAddressRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* AsyncDisableBreakpointByAddressRaw(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByAddressRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* PrepareAsyncDisableBreakpointByAddressRaw(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByAddressRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* AsyncEnableBreakpointByNameRaw(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByNameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* PrepareAsyncEnableBreakpointByNameRaw(::grpc::ClientContext* context, const ::TED::Grpc::EnableBreakpointByNameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* AsyncDisableBreakpointByNameRaw(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByNameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* PrepareAsyncDisableBreakpointByNameRaw(::grpc::ClientContext* context, const ::TED::Grpc::DisableBreakpointByNameRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::DisassembleAddressResponse>* AsyncDisassembleAddressRaw(::grpc::ClientContext* context, const ::TED::Grpc::DisassembleAddressRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::DisassembleAddressResponse>* PrepareAsyncDisassembleAddressRaw(::grpc::ClientContext* context, const ::TED::Grpc::DisassembleAddressRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* AsyncLoadModuleRaw(::grpc::ClientContext* context, const ::TED::Grpc::LoadModuleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* PrepareAsyncLoadModuleRaw(::grpc::ClientContext* context, const ::TED::Grpc::LoadModuleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* AsyncUnloadModuleRaw(::grpc::ClientContext* context, const ::TED::Grpc::UnloadModuleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* PrepareAsyncUnloadModuleRaw(::grpc::ClientContext* context, const ::TED::Grpc::UnloadModuleRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::ReadMemoryResponse>* AsyncReadMemoryRaw(::grpc::ClientContext* context, const ::TED::Grpc::ReadMemoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::ReadMemoryResponse>* PrepareAsyncReadMemoryRaw(::grpc::ClientContext* context, const ::TED::Grpc::ReadMemoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* AsyncWriteMemoryRaw(::grpc::ClientContext* context, const ::TED::Grpc::WriteMemoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* PrepareAsyncWriteMemoryRaw(::grpc::ClientContext* context, const ::TED::Grpc::WriteMemoryRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* AsyncCreateConsoleRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* PrepareAsyncCreateConsoleRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* AsyncDestroyConsoleRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* PrepareAsyncDestroyConsoleRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* AsyncEnableInternalLoggingRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* PrepareAsyncEnableInternalLoggingRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* AsyncDisableInternalLoggingRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* PrepareAsyncDisableInternalLoggingRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* AsyncOptionsRaw(::grpc::ClientContext* context, const ::TED::Grpc::OptionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* PrepareAsyncOptionsRaw(::grpc::ClientContext* context, const ::TED::Grpc::OptionsRequest& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* AsyncTestFunctionRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) override;
    ::grpc::ClientAsyncResponseReader< ::TED::Grpc::GenericResponse>* PrepareAsyncTestFunctionRaw(::grpc::ClientContext* context, const ::TED::Grpc::Empty& request, ::grpc::CompletionQueue* cq) override;
    const ::grpc::internal::RpcMethod rpcmethod_GetBreakpoints_;
    const ::grpc::internal::RpcMethod rpcmethod_GetModules_;
    const ::grpc::internal::RpcMethod rpcmethod_EnableBreakAllCallsInModule_;
    const ::grpc::internal::RpcMethod rpcmethod_DisableBreakAllCallsInModule_;
    const ::grpc::internal::RpcMethod rpcmethod_EnableBreakCallByAddress_;
    const ::grpc::internal::RpcMethod rpcmethod_DisableBreakCallByAddress_;
    const ::grpc::internal::RpcMethod rpcmethod_EnableBreakCallByName_;
    const ::grpc::internal::RpcMethod rpcmethod_DisableBreakCallByName_;
    const ::grpc::internal::RpcMethod rpcmethod_EnableBreakpointByAddress_;
    const ::grpc::internal::RpcMethod rpcmethod_DisableBreakpointByAddress_;
    const ::grpc::internal::RpcMethod rpcmethod_EnableBreakpointByName_;
    const ::grpc::internal::RpcMethod rpcmethod_DisableBreakpointByName_;
    const ::grpc::internal::RpcMethod rpcmethod_DisassembleAddress_;
    const ::grpc::internal::RpcMethod rpcmethod_LoadModule_;
    const ::grpc::internal::RpcMethod rpcmethod_UnloadModule_;
    const ::grpc::internal::RpcMethod rpcmethod_ReadMemory_;
    const ::grpc::internal::RpcMethod rpcmethod_WriteMemory_;
    const ::grpc::internal::RpcMethod rpcmethod_CreateConsole_;
    const ::grpc::internal::RpcMethod rpcmethod_DestroyConsole_;
    const ::grpc::internal::RpcMethod rpcmethod_EnableInternalLogging_;
    const ::grpc::internal::RpcMethod rpcmethod_DisableInternalLogging_;
    const ::grpc::internal::RpcMethod rpcmethod_Options_;
    const ::grpc::internal::RpcMethod rpcmethod_TestFunction_;
  };
  static std::unique_ptr<Stub> NewStub(const std::shared_ptr< ::grpc::ChannelInterface>& channel, const ::grpc::StubOptions& options = ::grpc::StubOptions());

  class Service : public ::grpc::Service {
   public:
    Service();
    virtual ~Service();
    virtual ::grpc::Status GetBreakpoints(::grpc::ServerContext* context, const ::TED::Grpc::Empty* request, ::grpc::ServerWriter< ::TED::Grpc::BreakpointResponse>* writer);
    virtual ::grpc::Status GetModules(::grpc::ServerContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GetModulesResponse* response);
    virtual ::grpc::Status EnableBreakAllCallsInModule(::grpc::ServerContext* context, const ::TED::Grpc::EnableBreakAllCallsInModuleRequest* request, ::TED::Grpc::GenericResponse* response);
    virtual ::grpc::Status DisableBreakAllCallsInModule(::grpc::ServerContext* context, const ::TED::Grpc::DisableBreakAllCallsInModuleRequest* request, ::TED::Grpc::GenericResponse* response);
    virtual ::grpc::Status EnableBreakCallByAddress(::grpc::ServerContext* context, const ::TED::Grpc::EnableBreakCallByAddressRequest* request, ::TED::Grpc::GenericResponse* response);
    virtual ::grpc::Status DisableBreakCallByAddress(::grpc::ServerContext* context, const ::TED::Grpc::DisableBreakCallByAddressRequest* request, ::TED::Grpc::GenericResponse* response);
    virtual ::grpc::Status EnableBreakCallByName(::grpc::ServerContext* context, const ::TED::Grpc::EnableBreakCallByNameRequest* request, ::TED::Grpc::GenericResponse* response);
    virtual ::grpc::Status DisableBreakCallByName(::grpc::ServerContext* context, const ::TED::Grpc::DisableBreakCallByNameRequest* request, ::TED::Grpc::GenericResponse* response);
    virtual ::grpc::Status EnableBreakpointByAddress(::grpc::ServerContext* context, const ::TED::Grpc::EnableBreakpointByAddressRequest* request, ::TED::Grpc::GenericResponse* response);
    virtual ::grpc::Status DisableBreakpointByAddress(::grpc::ServerContext* context, const ::TED::Grpc::DisableBreakpointByAddressRequest* request, ::TED::Grpc::GenericResponse* response);
    virtual ::grpc::Status EnableBreakpointByName(::grpc::ServerContext* context, const ::TED::Grpc::EnableBreakpointByNameRequest* request, ::TED::Grpc::GenericResponse* response);
    virtual ::grpc::Status DisableBreakpointByName(::grpc::ServerContext* context, const ::TED::Grpc::DisableBreakpointByNameRequest* request, ::TED::Grpc::GenericResponse* response);
    virtual ::grpc::Status DisassembleAddress(::grpc::ServerContext* context, const ::TED::Grpc::DisassembleAddressRequest* request, ::TED::Grpc::DisassembleAddressResponse* response);
    virtual ::grpc::Status LoadModule(::grpc::ServerContext* context, const ::TED::Grpc::LoadModuleRequest* request, ::TED::Grpc::GenericResponse* response);
    virtual ::grpc::Status UnloadModule(::grpc::ServerContext* context, const ::TED::Grpc::UnloadModuleRequest* request, ::TED::Grpc::GenericResponse* response);
    virtual ::grpc::Status ReadMemory(::grpc::ServerContext* context, const ::TED::Grpc::ReadMemoryRequest* request, ::TED::Grpc::ReadMemoryResponse* response);
    virtual ::grpc::Status WriteMemory(::grpc::ServerContext* context, const ::TED::Grpc::WriteMemoryRequest* request, ::TED::Grpc::GenericResponse* response);
    virtual ::grpc::Status CreateConsole(::grpc::ServerContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response);
    virtual ::grpc::Status DestroyConsole(::grpc::ServerContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response);
    virtual ::grpc::Status EnableInternalLogging(::grpc::ServerContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response);
    virtual ::grpc::Status DisableInternalLogging(::grpc::ServerContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response);
    virtual ::grpc::Status Options(::grpc::ServerContext* context, const ::TED::Grpc::OptionsRequest* request, ::TED::Grpc::GenericResponse* response);
    virtual ::grpc::Status TestFunction(::grpc::ServerContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response);
  };
  template <class BaseClass>
  class WithAsyncMethod_GetBreakpoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetBreakpoints() {
      ::grpc::Service::MarkMethodAsync(0);
    }
    ~WithAsyncMethod_GetBreakpoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBreakpoints(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::grpc::ServerWriter< ::TED::Grpc::BreakpointResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBreakpoints(::grpc::ServerContext* context, ::TED::Grpc::Empty* request, ::grpc::ServerAsyncWriter< ::TED::Grpc::BreakpointResponse>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_GetModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_GetModules() {
      ::grpc::Service::MarkMethodAsync(1);
    }
    ~WithAsyncMethod_GetModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModules(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GetModulesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetModules(::grpc::ServerContext* context, ::TED::Grpc::Empty* request, ::grpc::ServerAsyncResponseWriter< ::TED::Grpc::GetModulesResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EnableBreakAllCallsInModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EnableBreakAllCallsInModule() {
      ::grpc::Service::MarkMethodAsync(2);
    }
    ~WithAsyncMethod_EnableBreakAllCallsInModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBreakAllCallsInModule(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakAllCallsInModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnableBreakAllCallsInModule(::grpc::ServerContext* context, ::TED::Grpc::EnableBreakAllCallsInModuleRequest* request, ::grpc::ServerAsyncResponseWriter< ::TED::Grpc::GenericResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DisableBreakAllCallsInModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DisableBreakAllCallsInModule() {
      ::grpc::Service::MarkMethodAsync(3);
    }
    ~WithAsyncMethod_DisableBreakAllCallsInModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableBreakAllCallsInModule(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakAllCallsInModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisableBreakAllCallsInModule(::grpc::ServerContext* context, ::TED::Grpc::DisableBreakAllCallsInModuleRequest* request, ::grpc::ServerAsyncResponseWriter< ::TED::Grpc::GenericResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EnableBreakCallByAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EnableBreakCallByAddress() {
      ::grpc::Service::MarkMethodAsync(4);
    }
    ~WithAsyncMethod_EnableBreakCallByAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBreakCallByAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakCallByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnableBreakCallByAddress(::grpc::ServerContext* context, ::TED::Grpc::EnableBreakCallByAddressRequest* request, ::grpc::ServerAsyncResponseWriter< ::TED::Grpc::GenericResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DisableBreakCallByAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DisableBreakCallByAddress() {
      ::grpc::Service::MarkMethodAsync(5);
    }
    ~WithAsyncMethod_DisableBreakCallByAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableBreakCallByAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakCallByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisableBreakCallByAddress(::grpc::ServerContext* context, ::TED::Grpc::DisableBreakCallByAddressRequest* request, ::grpc::ServerAsyncResponseWriter< ::TED::Grpc::GenericResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EnableBreakCallByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EnableBreakCallByName() {
      ::grpc::Service::MarkMethodAsync(6);
    }
    ~WithAsyncMethod_EnableBreakCallByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBreakCallByName(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakCallByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnableBreakCallByName(::grpc::ServerContext* context, ::TED::Grpc::EnableBreakCallByNameRequest* request, ::grpc::ServerAsyncResponseWriter< ::TED::Grpc::GenericResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DisableBreakCallByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DisableBreakCallByName() {
      ::grpc::Service::MarkMethodAsync(7);
    }
    ~WithAsyncMethod_DisableBreakCallByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableBreakCallByName(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakCallByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisableBreakCallByName(::grpc::ServerContext* context, ::TED::Grpc::DisableBreakCallByNameRequest* request, ::grpc::ServerAsyncResponseWriter< ::TED::Grpc::GenericResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EnableBreakpointByAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EnableBreakpointByAddress() {
      ::grpc::Service::MarkMethodAsync(8);
    }
    ~WithAsyncMethod_EnableBreakpointByAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBreakpointByAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakpointByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnableBreakpointByAddress(::grpc::ServerContext* context, ::TED::Grpc::EnableBreakpointByAddressRequest* request, ::grpc::ServerAsyncResponseWriter< ::TED::Grpc::GenericResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DisableBreakpointByAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DisableBreakpointByAddress() {
      ::grpc::Service::MarkMethodAsync(9);
    }
    ~WithAsyncMethod_DisableBreakpointByAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableBreakpointByAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakpointByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisableBreakpointByAddress(::grpc::ServerContext* context, ::TED::Grpc::DisableBreakpointByAddressRequest* request, ::grpc::ServerAsyncResponseWriter< ::TED::Grpc::GenericResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EnableBreakpointByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EnableBreakpointByName() {
      ::grpc::Service::MarkMethodAsync(10);
    }
    ~WithAsyncMethod_EnableBreakpointByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBreakpointByName(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakpointByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnableBreakpointByName(::grpc::ServerContext* context, ::TED::Grpc::EnableBreakpointByNameRequest* request, ::grpc::ServerAsyncResponseWriter< ::TED::Grpc::GenericResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DisableBreakpointByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DisableBreakpointByName() {
      ::grpc::Service::MarkMethodAsync(11);
    }
    ~WithAsyncMethod_DisableBreakpointByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableBreakpointByName(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakpointByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisableBreakpointByName(::grpc::ServerContext* context, ::TED::Grpc::DisableBreakpointByNameRequest* request, ::grpc::ServerAsyncResponseWriter< ::TED::Grpc::GenericResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DisassembleAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DisassembleAddress() {
      ::grpc::Service::MarkMethodAsync(12);
    }
    ~WithAsyncMethod_DisassembleAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisassembleAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisassembleAddressRequest* /*request*/, ::TED::Grpc::DisassembleAddressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisassembleAddress(::grpc::ServerContext* context, ::TED::Grpc::DisassembleAddressRequest* request, ::grpc::ServerAsyncResponseWriter< ::TED::Grpc::DisassembleAddressResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_LoadModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_LoadModule() {
      ::grpc::Service::MarkMethodAsync(13);
    }
    ~WithAsyncMethod_LoadModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadModule(::grpc::ServerContext* /*context*/, const ::TED::Grpc::LoadModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoadModule(::grpc::ServerContext* context, ::TED::Grpc::LoadModuleRequest* request, ::grpc::ServerAsyncResponseWriter< ::TED::Grpc::GenericResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_UnloadModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_UnloadModule() {
      ::grpc::Service::MarkMethodAsync(14);
    }
    ~WithAsyncMethod_UnloadModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnloadModule(::grpc::ServerContext* /*context*/, const ::TED::Grpc::UnloadModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnloadModule(::grpc::ServerContext* context, ::TED::Grpc::UnloadModuleRequest* request, ::grpc::ServerAsyncResponseWriter< ::TED::Grpc::GenericResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_ReadMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_ReadMemory() {
      ::grpc::Service::MarkMethodAsync(15);
    }
    ~WithAsyncMethod_ReadMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadMemory(::grpc::ServerContext* /*context*/, const ::TED::Grpc::ReadMemoryRequest* /*request*/, ::TED::Grpc::ReadMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadMemory(::grpc::ServerContext* context, ::TED::Grpc::ReadMemoryRequest* request, ::grpc::ServerAsyncResponseWriter< ::TED::Grpc::ReadMemoryResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_WriteMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_WriteMemory() {
      ::grpc::Service::MarkMethodAsync(16);
    }
    ~WithAsyncMethod_WriteMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteMemory(::grpc::ServerContext* /*context*/, const ::TED::Grpc::WriteMemoryRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWriteMemory(::grpc::ServerContext* context, ::TED::Grpc::WriteMemoryRequest* request, ::grpc::ServerAsyncResponseWriter< ::TED::Grpc::GenericResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_CreateConsole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_CreateConsole() {
      ::grpc::Service::MarkMethodAsync(17);
    }
    ~WithAsyncMethod_CreateConsole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateConsole(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateConsole(::grpc::ServerContext* context, ::TED::Grpc::Empty* request, ::grpc::ServerAsyncResponseWriter< ::TED::Grpc::GenericResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DestroyConsole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DestroyConsole() {
      ::grpc::Service::MarkMethodAsync(18);
    }
    ~WithAsyncMethod_DestroyConsole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyConsole(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDestroyConsole(::grpc::ServerContext* context, ::TED::Grpc::Empty* request, ::grpc::ServerAsyncResponseWriter< ::TED::Grpc::GenericResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_EnableInternalLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_EnableInternalLogging() {
      ::grpc::Service::MarkMethodAsync(19);
    }
    ~WithAsyncMethod_EnableInternalLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableInternalLogging(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnableInternalLogging(::grpc::ServerContext* context, ::TED::Grpc::Empty* request, ::grpc::ServerAsyncResponseWriter< ::TED::Grpc::GenericResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_DisableInternalLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_DisableInternalLogging() {
      ::grpc::Service::MarkMethodAsync(20);
    }
    ~WithAsyncMethod_DisableInternalLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableInternalLogging(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisableInternalLogging(::grpc::ServerContext* context, ::TED::Grpc::Empty* request, ::grpc::ServerAsyncResponseWriter< ::TED::Grpc::GenericResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_Options : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_Options() {
      ::grpc::Service::MarkMethodAsync(21);
    }
    ~WithAsyncMethod_Options() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Options(::grpc::ServerContext* /*context*/, const ::TED::Grpc::OptionsRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOptions(::grpc::ServerContext* context, ::TED::Grpc::OptionsRequest* request, ::grpc::ServerAsyncResponseWriter< ::TED::Grpc::GenericResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithAsyncMethod_TestFunction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithAsyncMethod_TestFunction() {
      ::grpc::Service::MarkMethodAsync(22);
    }
    ~WithAsyncMethod_TestFunction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TestFunction(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTestFunction(::grpc::ServerContext* context, ::TED::Grpc::Empty* request, ::grpc::ServerAsyncResponseWriter< ::TED::Grpc::GenericResponse>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  typedef WithAsyncMethod_GetBreakpoints<WithAsyncMethod_GetModules<WithAsyncMethod_EnableBreakAllCallsInModule<WithAsyncMethod_DisableBreakAllCallsInModule<WithAsyncMethod_EnableBreakCallByAddress<WithAsyncMethod_DisableBreakCallByAddress<WithAsyncMethod_EnableBreakCallByName<WithAsyncMethod_DisableBreakCallByName<WithAsyncMethod_EnableBreakpointByAddress<WithAsyncMethod_DisableBreakpointByAddress<WithAsyncMethod_EnableBreakpointByName<WithAsyncMethod_DisableBreakpointByName<WithAsyncMethod_DisassembleAddress<WithAsyncMethod_LoadModule<WithAsyncMethod_UnloadModule<WithAsyncMethod_ReadMemory<WithAsyncMethod_WriteMemory<WithAsyncMethod_CreateConsole<WithAsyncMethod_DestroyConsole<WithAsyncMethod_EnableInternalLogging<WithAsyncMethod_DisableInternalLogging<WithAsyncMethod_Options<WithAsyncMethod_TestFunction<Service > > > > > > > > > > > > > > > > > > > > > > > AsyncService;
  template <class BaseClass>
  class WithCallbackMethod_GetBreakpoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetBreakpoints() {
      ::grpc::Service::MarkMethodCallback(0,
          new ::grpc::internal::CallbackServerStreamingHandler< ::TED::Grpc::Empty, ::TED::Grpc::BreakpointResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TED::Grpc::Empty* request) { return this->GetBreakpoints(context, request); }));
    }
    ~WithCallbackMethod_GetBreakpoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBreakpoints(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::grpc::ServerWriter< ::TED::Grpc::BreakpointResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::TED::Grpc::BreakpointResponse>* GetBreakpoints(
      ::grpc::CallbackServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_GetModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_GetModules() {
      ::grpc::Service::MarkMethodCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::Empty, ::TED::Grpc::GetModulesResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GetModulesResponse* response) { return this->GetModules(context, request, response); }));}
    void SetMessageAllocatorFor_GetModules(
        ::grpc::MessageAllocator< ::TED::Grpc::Empty, ::TED::Grpc::GetModulesResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(1);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::Empty, ::TED::Grpc::GetModulesResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_GetModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModules(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GetModulesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetModules(
      ::grpc::CallbackServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GetModulesResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_EnableBreakAllCallsInModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_EnableBreakAllCallsInModule() {
      ::grpc::Service::MarkMethodCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::EnableBreakAllCallsInModuleRequest, ::TED::Grpc::GenericResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TED::Grpc::EnableBreakAllCallsInModuleRequest* request, ::TED::Grpc::GenericResponse* response) { return this->EnableBreakAllCallsInModule(context, request, response); }));}
    void SetMessageAllocatorFor_EnableBreakAllCallsInModule(
        ::grpc::MessageAllocator< ::TED::Grpc::EnableBreakAllCallsInModuleRequest, ::TED::Grpc::GenericResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(2);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::EnableBreakAllCallsInModuleRequest, ::TED::Grpc::GenericResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_EnableBreakAllCallsInModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBreakAllCallsInModule(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakAllCallsInModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* EnableBreakAllCallsInModule(
      ::grpc::CallbackServerContext* /*context*/, const ::TED::Grpc::EnableBreakAllCallsInModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DisableBreakAllCallsInModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DisableBreakAllCallsInModule() {
      ::grpc::Service::MarkMethodCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::DisableBreakAllCallsInModuleRequest, ::TED::Grpc::GenericResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TED::Grpc::DisableBreakAllCallsInModuleRequest* request, ::TED::Grpc::GenericResponse* response) { return this->DisableBreakAllCallsInModule(context, request, response); }));}
    void SetMessageAllocatorFor_DisableBreakAllCallsInModule(
        ::grpc::MessageAllocator< ::TED::Grpc::DisableBreakAllCallsInModuleRequest, ::TED::Grpc::GenericResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(3);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::DisableBreakAllCallsInModuleRequest, ::TED::Grpc::GenericResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DisableBreakAllCallsInModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableBreakAllCallsInModule(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakAllCallsInModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DisableBreakAllCallsInModule(
      ::grpc::CallbackServerContext* /*context*/, const ::TED::Grpc::DisableBreakAllCallsInModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_EnableBreakCallByAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_EnableBreakCallByAddress() {
      ::grpc::Service::MarkMethodCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::EnableBreakCallByAddressRequest, ::TED::Grpc::GenericResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TED::Grpc::EnableBreakCallByAddressRequest* request, ::TED::Grpc::GenericResponse* response) { return this->EnableBreakCallByAddress(context, request, response); }));}
    void SetMessageAllocatorFor_EnableBreakCallByAddress(
        ::grpc::MessageAllocator< ::TED::Grpc::EnableBreakCallByAddressRequest, ::TED::Grpc::GenericResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(4);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::EnableBreakCallByAddressRequest, ::TED::Grpc::GenericResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_EnableBreakCallByAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBreakCallByAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakCallByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* EnableBreakCallByAddress(
      ::grpc::CallbackServerContext* /*context*/, const ::TED::Grpc::EnableBreakCallByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DisableBreakCallByAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DisableBreakCallByAddress() {
      ::grpc::Service::MarkMethodCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::DisableBreakCallByAddressRequest, ::TED::Grpc::GenericResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TED::Grpc::DisableBreakCallByAddressRequest* request, ::TED::Grpc::GenericResponse* response) { return this->DisableBreakCallByAddress(context, request, response); }));}
    void SetMessageAllocatorFor_DisableBreakCallByAddress(
        ::grpc::MessageAllocator< ::TED::Grpc::DisableBreakCallByAddressRequest, ::TED::Grpc::GenericResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(5);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::DisableBreakCallByAddressRequest, ::TED::Grpc::GenericResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DisableBreakCallByAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableBreakCallByAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakCallByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DisableBreakCallByAddress(
      ::grpc::CallbackServerContext* /*context*/, const ::TED::Grpc::DisableBreakCallByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_EnableBreakCallByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_EnableBreakCallByName() {
      ::grpc::Service::MarkMethodCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::EnableBreakCallByNameRequest, ::TED::Grpc::GenericResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TED::Grpc::EnableBreakCallByNameRequest* request, ::TED::Grpc::GenericResponse* response) { return this->EnableBreakCallByName(context, request, response); }));}
    void SetMessageAllocatorFor_EnableBreakCallByName(
        ::grpc::MessageAllocator< ::TED::Grpc::EnableBreakCallByNameRequest, ::TED::Grpc::GenericResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(6);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::EnableBreakCallByNameRequest, ::TED::Grpc::GenericResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_EnableBreakCallByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBreakCallByName(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakCallByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* EnableBreakCallByName(
      ::grpc::CallbackServerContext* /*context*/, const ::TED::Grpc::EnableBreakCallByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DisableBreakCallByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DisableBreakCallByName() {
      ::grpc::Service::MarkMethodCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::DisableBreakCallByNameRequest, ::TED::Grpc::GenericResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TED::Grpc::DisableBreakCallByNameRequest* request, ::TED::Grpc::GenericResponse* response) { return this->DisableBreakCallByName(context, request, response); }));}
    void SetMessageAllocatorFor_DisableBreakCallByName(
        ::grpc::MessageAllocator< ::TED::Grpc::DisableBreakCallByNameRequest, ::TED::Grpc::GenericResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(7);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::DisableBreakCallByNameRequest, ::TED::Grpc::GenericResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DisableBreakCallByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableBreakCallByName(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakCallByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DisableBreakCallByName(
      ::grpc::CallbackServerContext* /*context*/, const ::TED::Grpc::DisableBreakCallByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_EnableBreakpointByAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_EnableBreakpointByAddress() {
      ::grpc::Service::MarkMethodCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::EnableBreakpointByAddressRequest, ::TED::Grpc::GenericResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TED::Grpc::EnableBreakpointByAddressRequest* request, ::TED::Grpc::GenericResponse* response) { return this->EnableBreakpointByAddress(context, request, response); }));}
    void SetMessageAllocatorFor_EnableBreakpointByAddress(
        ::grpc::MessageAllocator< ::TED::Grpc::EnableBreakpointByAddressRequest, ::TED::Grpc::GenericResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(8);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::EnableBreakpointByAddressRequest, ::TED::Grpc::GenericResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_EnableBreakpointByAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBreakpointByAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakpointByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* EnableBreakpointByAddress(
      ::grpc::CallbackServerContext* /*context*/, const ::TED::Grpc::EnableBreakpointByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DisableBreakpointByAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DisableBreakpointByAddress() {
      ::grpc::Service::MarkMethodCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::DisableBreakpointByAddressRequest, ::TED::Grpc::GenericResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TED::Grpc::DisableBreakpointByAddressRequest* request, ::TED::Grpc::GenericResponse* response) { return this->DisableBreakpointByAddress(context, request, response); }));}
    void SetMessageAllocatorFor_DisableBreakpointByAddress(
        ::grpc::MessageAllocator< ::TED::Grpc::DisableBreakpointByAddressRequest, ::TED::Grpc::GenericResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(9);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::DisableBreakpointByAddressRequest, ::TED::Grpc::GenericResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DisableBreakpointByAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableBreakpointByAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakpointByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DisableBreakpointByAddress(
      ::grpc::CallbackServerContext* /*context*/, const ::TED::Grpc::DisableBreakpointByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_EnableBreakpointByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_EnableBreakpointByName() {
      ::grpc::Service::MarkMethodCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::EnableBreakpointByNameRequest, ::TED::Grpc::GenericResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TED::Grpc::EnableBreakpointByNameRequest* request, ::TED::Grpc::GenericResponse* response) { return this->EnableBreakpointByName(context, request, response); }));}
    void SetMessageAllocatorFor_EnableBreakpointByName(
        ::grpc::MessageAllocator< ::TED::Grpc::EnableBreakpointByNameRequest, ::TED::Grpc::GenericResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(10);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::EnableBreakpointByNameRequest, ::TED::Grpc::GenericResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_EnableBreakpointByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBreakpointByName(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakpointByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* EnableBreakpointByName(
      ::grpc::CallbackServerContext* /*context*/, const ::TED::Grpc::EnableBreakpointByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DisableBreakpointByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DisableBreakpointByName() {
      ::grpc::Service::MarkMethodCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::DisableBreakpointByNameRequest, ::TED::Grpc::GenericResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TED::Grpc::DisableBreakpointByNameRequest* request, ::TED::Grpc::GenericResponse* response) { return this->DisableBreakpointByName(context, request, response); }));}
    void SetMessageAllocatorFor_DisableBreakpointByName(
        ::grpc::MessageAllocator< ::TED::Grpc::DisableBreakpointByNameRequest, ::TED::Grpc::GenericResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(11);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::DisableBreakpointByNameRequest, ::TED::Grpc::GenericResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DisableBreakpointByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableBreakpointByName(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakpointByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DisableBreakpointByName(
      ::grpc::CallbackServerContext* /*context*/, const ::TED::Grpc::DisableBreakpointByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DisassembleAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DisassembleAddress() {
      ::grpc::Service::MarkMethodCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::DisassembleAddressRequest, ::TED::Grpc::DisassembleAddressResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TED::Grpc::DisassembleAddressRequest* request, ::TED::Grpc::DisassembleAddressResponse* response) { return this->DisassembleAddress(context, request, response); }));}
    void SetMessageAllocatorFor_DisassembleAddress(
        ::grpc::MessageAllocator< ::TED::Grpc::DisassembleAddressRequest, ::TED::Grpc::DisassembleAddressResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(12);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::DisassembleAddressRequest, ::TED::Grpc::DisassembleAddressResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DisassembleAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisassembleAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisassembleAddressRequest* /*request*/, ::TED::Grpc::DisassembleAddressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DisassembleAddress(
      ::grpc::CallbackServerContext* /*context*/, const ::TED::Grpc::DisassembleAddressRequest* /*request*/, ::TED::Grpc::DisassembleAddressResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_LoadModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_LoadModule() {
      ::grpc::Service::MarkMethodCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::LoadModuleRequest, ::TED::Grpc::GenericResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TED::Grpc::LoadModuleRequest* request, ::TED::Grpc::GenericResponse* response) { return this->LoadModule(context, request, response); }));}
    void SetMessageAllocatorFor_LoadModule(
        ::grpc::MessageAllocator< ::TED::Grpc::LoadModuleRequest, ::TED::Grpc::GenericResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(13);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::LoadModuleRequest, ::TED::Grpc::GenericResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_LoadModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadModule(::grpc::ServerContext* /*context*/, const ::TED::Grpc::LoadModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LoadModule(
      ::grpc::CallbackServerContext* /*context*/, const ::TED::Grpc::LoadModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_UnloadModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_UnloadModule() {
      ::grpc::Service::MarkMethodCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::UnloadModuleRequest, ::TED::Grpc::GenericResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TED::Grpc::UnloadModuleRequest* request, ::TED::Grpc::GenericResponse* response) { return this->UnloadModule(context, request, response); }));}
    void SetMessageAllocatorFor_UnloadModule(
        ::grpc::MessageAllocator< ::TED::Grpc::UnloadModuleRequest, ::TED::Grpc::GenericResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(14);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::UnloadModuleRequest, ::TED::Grpc::GenericResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_UnloadModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnloadModule(::grpc::ServerContext* /*context*/, const ::TED::Grpc::UnloadModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UnloadModule(
      ::grpc::CallbackServerContext* /*context*/, const ::TED::Grpc::UnloadModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_ReadMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_ReadMemory() {
      ::grpc::Service::MarkMethodCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::ReadMemoryRequest, ::TED::Grpc::ReadMemoryResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TED::Grpc::ReadMemoryRequest* request, ::TED::Grpc::ReadMemoryResponse* response) { return this->ReadMemory(context, request, response); }));}
    void SetMessageAllocatorFor_ReadMemory(
        ::grpc::MessageAllocator< ::TED::Grpc::ReadMemoryRequest, ::TED::Grpc::ReadMemoryResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(15);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::ReadMemoryRequest, ::TED::Grpc::ReadMemoryResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_ReadMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadMemory(::grpc::ServerContext* /*context*/, const ::TED::Grpc::ReadMemoryRequest* /*request*/, ::TED::Grpc::ReadMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReadMemory(
      ::grpc::CallbackServerContext* /*context*/, const ::TED::Grpc::ReadMemoryRequest* /*request*/, ::TED::Grpc::ReadMemoryResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_WriteMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_WriteMemory() {
      ::grpc::Service::MarkMethodCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::WriteMemoryRequest, ::TED::Grpc::GenericResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TED::Grpc::WriteMemoryRequest* request, ::TED::Grpc::GenericResponse* response) { return this->WriteMemory(context, request, response); }));}
    void SetMessageAllocatorFor_WriteMemory(
        ::grpc::MessageAllocator< ::TED::Grpc::WriteMemoryRequest, ::TED::Grpc::GenericResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(16);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::WriteMemoryRequest, ::TED::Grpc::GenericResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_WriteMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteMemory(::grpc::ServerContext* /*context*/, const ::TED::Grpc::WriteMemoryRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WriteMemory(
      ::grpc::CallbackServerContext* /*context*/, const ::TED::Grpc::WriteMemoryRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_CreateConsole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_CreateConsole() {
      ::grpc::Service::MarkMethodCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::Empty, ::TED::Grpc::GenericResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response) { return this->CreateConsole(context, request, response); }));}
    void SetMessageAllocatorFor_CreateConsole(
        ::grpc::MessageAllocator< ::TED::Grpc::Empty, ::TED::Grpc::GenericResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(17);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::Empty, ::TED::Grpc::GenericResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_CreateConsole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateConsole(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateConsole(
      ::grpc::CallbackServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DestroyConsole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DestroyConsole() {
      ::grpc::Service::MarkMethodCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::Empty, ::TED::Grpc::GenericResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response) { return this->DestroyConsole(context, request, response); }));}
    void SetMessageAllocatorFor_DestroyConsole(
        ::grpc::MessageAllocator< ::TED::Grpc::Empty, ::TED::Grpc::GenericResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(18);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::Empty, ::TED::Grpc::GenericResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DestroyConsole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyConsole(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DestroyConsole(
      ::grpc::CallbackServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_EnableInternalLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_EnableInternalLogging() {
      ::grpc::Service::MarkMethodCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::Empty, ::TED::Grpc::GenericResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response) { return this->EnableInternalLogging(context, request, response); }));}
    void SetMessageAllocatorFor_EnableInternalLogging(
        ::grpc::MessageAllocator< ::TED::Grpc::Empty, ::TED::Grpc::GenericResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(19);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::Empty, ::TED::Grpc::GenericResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_EnableInternalLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableInternalLogging(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* EnableInternalLogging(
      ::grpc::CallbackServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_DisableInternalLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_DisableInternalLogging() {
      ::grpc::Service::MarkMethodCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::Empty, ::TED::Grpc::GenericResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response) { return this->DisableInternalLogging(context, request, response); }));}
    void SetMessageAllocatorFor_DisableInternalLogging(
        ::grpc::MessageAllocator< ::TED::Grpc::Empty, ::TED::Grpc::GenericResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(20);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::Empty, ::TED::Grpc::GenericResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_DisableInternalLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableInternalLogging(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DisableInternalLogging(
      ::grpc::CallbackServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_Options : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_Options() {
      ::grpc::Service::MarkMethodCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::OptionsRequest, ::TED::Grpc::GenericResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TED::Grpc::OptionsRequest* request, ::TED::Grpc::GenericResponse* response) { return this->Options(context, request, response); }));}
    void SetMessageAllocatorFor_Options(
        ::grpc::MessageAllocator< ::TED::Grpc::OptionsRequest, ::TED::Grpc::GenericResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(21);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::OptionsRequest, ::TED::Grpc::GenericResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_Options() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Options(::grpc::ServerContext* /*context*/, const ::TED::Grpc::OptionsRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Options(
      ::grpc::CallbackServerContext* /*context*/, const ::TED::Grpc::OptionsRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithCallbackMethod_TestFunction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithCallbackMethod_TestFunction() {
      ::grpc::Service::MarkMethodCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::Empty, ::TED::Grpc::GenericResponse>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::TED::Grpc::Empty* request, ::TED::Grpc::GenericResponse* response) { return this->TestFunction(context, request, response); }));}
    void SetMessageAllocatorFor_TestFunction(
        ::grpc::MessageAllocator< ::TED::Grpc::Empty, ::TED::Grpc::GenericResponse>* allocator) {
      ::grpc::internal::MethodHandler* const handler = ::grpc::Service::GetHandler(22);
      static_cast<::grpc::internal::CallbackUnaryHandler< ::TED::Grpc::Empty, ::TED::Grpc::GenericResponse>*>(handler)
              ->SetMessageAllocator(allocator);
    }
    ~WithCallbackMethod_TestFunction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TestFunction(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TestFunction(
      ::grpc::CallbackServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/)  { return nullptr; }
  };
  typedef WithCallbackMethod_GetBreakpoints<WithCallbackMethod_GetModules<WithCallbackMethod_EnableBreakAllCallsInModule<WithCallbackMethod_DisableBreakAllCallsInModule<WithCallbackMethod_EnableBreakCallByAddress<WithCallbackMethod_DisableBreakCallByAddress<WithCallbackMethod_EnableBreakCallByName<WithCallbackMethod_DisableBreakCallByName<WithCallbackMethod_EnableBreakpointByAddress<WithCallbackMethod_DisableBreakpointByAddress<WithCallbackMethod_EnableBreakpointByName<WithCallbackMethod_DisableBreakpointByName<WithCallbackMethod_DisassembleAddress<WithCallbackMethod_LoadModule<WithCallbackMethod_UnloadModule<WithCallbackMethod_ReadMemory<WithCallbackMethod_WriteMemory<WithCallbackMethod_CreateConsole<WithCallbackMethod_DestroyConsole<WithCallbackMethod_EnableInternalLogging<WithCallbackMethod_DisableInternalLogging<WithCallbackMethod_Options<WithCallbackMethod_TestFunction<Service > > > > > > > > > > > > > > > > > > > > > > > CallbackService;
  typedef CallbackService ExperimentalCallbackService;
  template <class BaseClass>
  class WithGenericMethod_GetBreakpoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetBreakpoints() {
      ::grpc::Service::MarkMethodGeneric(0);
    }
    ~WithGenericMethod_GetBreakpoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBreakpoints(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::grpc::ServerWriter< ::TED::Grpc::BreakpointResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_GetModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_GetModules() {
      ::grpc::Service::MarkMethodGeneric(1);
    }
    ~WithGenericMethod_GetModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModules(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GetModulesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EnableBreakAllCallsInModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EnableBreakAllCallsInModule() {
      ::grpc::Service::MarkMethodGeneric(2);
    }
    ~WithGenericMethod_EnableBreakAllCallsInModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBreakAllCallsInModule(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakAllCallsInModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DisableBreakAllCallsInModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DisableBreakAllCallsInModule() {
      ::grpc::Service::MarkMethodGeneric(3);
    }
    ~WithGenericMethod_DisableBreakAllCallsInModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableBreakAllCallsInModule(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakAllCallsInModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EnableBreakCallByAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EnableBreakCallByAddress() {
      ::grpc::Service::MarkMethodGeneric(4);
    }
    ~WithGenericMethod_EnableBreakCallByAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBreakCallByAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakCallByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DisableBreakCallByAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DisableBreakCallByAddress() {
      ::grpc::Service::MarkMethodGeneric(5);
    }
    ~WithGenericMethod_DisableBreakCallByAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableBreakCallByAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakCallByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EnableBreakCallByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EnableBreakCallByName() {
      ::grpc::Service::MarkMethodGeneric(6);
    }
    ~WithGenericMethod_EnableBreakCallByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBreakCallByName(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakCallByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DisableBreakCallByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DisableBreakCallByName() {
      ::grpc::Service::MarkMethodGeneric(7);
    }
    ~WithGenericMethod_DisableBreakCallByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableBreakCallByName(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakCallByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EnableBreakpointByAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EnableBreakpointByAddress() {
      ::grpc::Service::MarkMethodGeneric(8);
    }
    ~WithGenericMethod_EnableBreakpointByAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBreakpointByAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakpointByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DisableBreakpointByAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DisableBreakpointByAddress() {
      ::grpc::Service::MarkMethodGeneric(9);
    }
    ~WithGenericMethod_DisableBreakpointByAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableBreakpointByAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakpointByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EnableBreakpointByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EnableBreakpointByName() {
      ::grpc::Service::MarkMethodGeneric(10);
    }
    ~WithGenericMethod_EnableBreakpointByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBreakpointByName(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakpointByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DisableBreakpointByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DisableBreakpointByName() {
      ::grpc::Service::MarkMethodGeneric(11);
    }
    ~WithGenericMethod_DisableBreakpointByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableBreakpointByName(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakpointByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DisassembleAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DisassembleAddress() {
      ::grpc::Service::MarkMethodGeneric(12);
    }
    ~WithGenericMethod_DisassembleAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisassembleAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisassembleAddressRequest* /*request*/, ::TED::Grpc::DisassembleAddressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_LoadModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_LoadModule() {
      ::grpc::Service::MarkMethodGeneric(13);
    }
    ~WithGenericMethod_LoadModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadModule(::grpc::ServerContext* /*context*/, const ::TED::Grpc::LoadModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_UnloadModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_UnloadModule() {
      ::grpc::Service::MarkMethodGeneric(14);
    }
    ~WithGenericMethod_UnloadModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnloadModule(::grpc::ServerContext* /*context*/, const ::TED::Grpc::UnloadModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_ReadMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_ReadMemory() {
      ::grpc::Service::MarkMethodGeneric(15);
    }
    ~WithGenericMethod_ReadMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadMemory(::grpc::ServerContext* /*context*/, const ::TED::Grpc::ReadMemoryRequest* /*request*/, ::TED::Grpc::ReadMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_WriteMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_WriteMemory() {
      ::grpc::Service::MarkMethodGeneric(16);
    }
    ~WithGenericMethod_WriteMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteMemory(::grpc::ServerContext* /*context*/, const ::TED::Grpc::WriteMemoryRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_CreateConsole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_CreateConsole() {
      ::grpc::Service::MarkMethodGeneric(17);
    }
    ~WithGenericMethod_CreateConsole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateConsole(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DestroyConsole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DestroyConsole() {
      ::grpc::Service::MarkMethodGeneric(18);
    }
    ~WithGenericMethod_DestroyConsole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyConsole(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_EnableInternalLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_EnableInternalLogging() {
      ::grpc::Service::MarkMethodGeneric(19);
    }
    ~WithGenericMethod_EnableInternalLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableInternalLogging(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_DisableInternalLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_DisableInternalLogging() {
      ::grpc::Service::MarkMethodGeneric(20);
    }
    ~WithGenericMethod_DisableInternalLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableInternalLogging(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_Options : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_Options() {
      ::grpc::Service::MarkMethodGeneric(21);
    }
    ~WithGenericMethod_Options() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Options(::grpc::ServerContext* /*context*/, const ::TED::Grpc::OptionsRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithGenericMethod_TestFunction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithGenericMethod_TestFunction() {
      ::grpc::Service::MarkMethodGeneric(22);
    }
    ~WithGenericMethod_TestFunction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TestFunction(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetBreakpoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetBreakpoints() {
      ::grpc::Service::MarkMethodRaw(0);
    }
    ~WithRawMethod_GetBreakpoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBreakpoints(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::grpc::ServerWriter< ::TED::Grpc::BreakpointResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetBreakpoints(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncWriter< ::grpc::ByteBuffer>* writer, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncServerStreaming(0, context, request, writer, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_GetModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_GetModules() {
      ::grpc::Service::MarkMethodRaw(1);
    }
    ~WithRawMethod_GetModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModules(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GetModulesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestGetModules(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(1, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EnableBreakAllCallsInModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EnableBreakAllCallsInModule() {
      ::grpc::Service::MarkMethodRaw(2);
    }
    ~WithRawMethod_EnableBreakAllCallsInModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBreakAllCallsInModule(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakAllCallsInModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnableBreakAllCallsInModule(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(2, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DisableBreakAllCallsInModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DisableBreakAllCallsInModule() {
      ::grpc::Service::MarkMethodRaw(3);
    }
    ~WithRawMethod_DisableBreakAllCallsInModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableBreakAllCallsInModule(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakAllCallsInModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisableBreakAllCallsInModule(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(3, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EnableBreakCallByAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EnableBreakCallByAddress() {
      ::grpc::Service::MarkMethodRaw(4);
    }
    ~WithRawMethod_EnableBreakCallByAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBreakCallByAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakCallByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnableBreakCallByAddress(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(4, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DisableBreakCallByAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DisableBreakCallByAddress() {
      ::grpc::Service::MarkMethodRaw(5);
    }
    ~WithRawMethod_DisableBreakCallByAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableBreakCallByAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakCallByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisableBreakCallByAddress(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(5, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EnableBreakCallByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EnableBreakCallByName() {
      ::grpc::Service::MarkMethodRaw(6);
    }
    ~WithRawMethod_EnableBreakCallByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBreakCallByName(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakCallByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnableBreakCallByName(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(6, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DisableBreakCallByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DisableBreakCallByName() {
      ::grpc::Service::MarkMethodRaw(7);
    }
    ~WithRawMethod_DisableBreakCallByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableBreakCallByName(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakCallByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisableBreakCallByName(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(7, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EnableBreakpointByAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EnableBreakpointByAddress() {
      ::grpc::Service::MarkMethodRaw(8);
    }
    ~WithRawMethod_EnableBreakpointByAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBreakpointByAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakpointByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnableBreakpointByAddress(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(8, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DisableBreakpointByAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DisableBreakpointByAddress() {
      ::grpc::Service::MarkMethodRaw(9);
    }
    ~WithRawMethod_DisableBreakpointByAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableBreakpointByAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakpointByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisableBreakpointByAddress(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(9, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EnableBreakpointByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EnableBreakpointByName() {
      ::grpc::Service::MarkMethodRaw(10);
    }
    ~WithRawMethod_EnableBreakpointByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBreakpointByName(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakpointByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnableBreakpointByName(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(10, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DisableBreakpointByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DisableBreakpointByName() {
      ::grpc::Service::MarkMethodRaw(11);
    }
    ~WithRawMethod_DisableBreakpointByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableBreakpointByName(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakpointByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisableBreakpointByName(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(11, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DisassembleAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DisassembleAddress() {
      ::grpc::Service::MarkMethodRaw(12);
    }
    ~WithRawMethod_DisassembleAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisassembleAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisassembleAddressRequest* /*request*/, ::TED::Grpc::DisassembleAddressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisassembleAddress(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(12, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_LoadModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_LoadModule() {
      ::grpc::Service::MarkMethodRaw(13);
    }
    ~WithRawMethod_LoadModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadModule(::grpc::ServerContext* /*context*/, const ::TED::Grpc::LoadModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestLoadModule(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(13, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_UnloadModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_UnloadModule() {
      ::grpc::Service::MarkMethodRaw(14);
    }
    ~WithRawMethod_UnloadModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnloadModule(::grpc::ServerContext* /*context*/, const ::TED::Grpc::UnloadModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestUnloadModule(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(14, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_ReadMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_ReadMemory() {
      ::grpc::Service::MarkMethodRaw(15);
    }
    ~WithRawMethod_ReadMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadMemory(::grpc::ServerContext* /*context*/, const ::TED::Grpc::ReadMemoryRequest* /*request*/, ::TED::Grpc::ReadMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestReadMemory(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(15, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_WriteMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_WriteMemory() {
      ::grpc::Service::MarkMethodRaw(16);
    }
    ~WithRawMethod_WriteMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteMemory(::grpc::ServerContext* /*context*/, const ::TED::Grpc::WriteMemoryRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestWriteMemory(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(16, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_CreateConsole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_CreateConsole() {
      ::grpc::Service::MarkMethodRaw(17);
    }
    ~WithRawMethod_CreateConsole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateConsole(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestCreateConsole(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(17, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DestroyConsole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DestroyConsole() {
      ::grpc::Service::MarkMethodRaw(18);
    }
    ~WithRawMethod_DestroyConsole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyConsole(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDestroyConsole(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(18, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_EnableInternalLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_EnableInternalLogging() {
      ::grpc::Service::MarkMethodRaw(19);
    }
    ~WithRawMethod_EnableInternalLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableInternalLogging(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestEnableInternalLogging(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(19, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_DisableInternalLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_DisableInternalLogging() {
      ::grpc::Service::MarkMethodRaw(20);
    }
    ~WithRawMethod_DisableInternalLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableInternalLogging(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestDisableInternalLogging(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(20, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_Options : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_Options() {
      ::grpc::Service::MarkMethodRaw(21);
    }
    ~WithRawMethod_Options() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Options(::grpc::ServerContext* /*context*/, const ::TED::Grpc::OptionsRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestOptions(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(21, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawMethod_TestFunction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawMethod_TestFunction() {
      ::grpc::Service::MarkMethodRaw(22);
    }
    ~WithRawMethod_TestFunction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TestFunction(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    void RequestTestFunction(::grpc::ServerContext* context, ::grpc::ByteBuffer* request, ::grpc::ServerAsyncResponseWriter< ::grpc::ByteBuffer>* response, ::grpc::CompletionQueue* new_call_cq, ::grpc::ServerCompletionQueue* notification_cq, void *tag) {
      ::grpc::Service::RequestAsyncUnary(22, context, request, response, new_call_cq, notification_cq, tag);
    }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetBreakpoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetBreakpoints() {
      ::grpc::Service::MarkMethodRawCallback(0,
          new ::grpc::internal::CallbackServerStreamingHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const::grpc::ByteBuffer* request) { return this->GetBreakpoints(context, request); }));
    }
    ~WithRawCallbackMethod_GetBreakpoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetBreakpoints(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::grpc::ServerWriter< ::TED::Grpc::BreakpointResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerWriteReactor< ::grpc::ByteBuffer>* GetBreakpoints(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_GetModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_GetModules() {
      ::grpc::Service::MarkMethodRawCallback(1,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->GetModules(context, request, response); }));
    }
    ~WithRawCallbackMethod_GetModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status GetModules(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GetModulesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* GetModules(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_EnableBreakAllCallsInModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_EnableBreakAllCallsInModule() {
      ::grpc::Service::MarkMethodRawCallback(2,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EnableBreakAllCallsInModule(context, request, response); }));
    }
    ~WithRawCallbackMethod_EnableBreakAllCallsInModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBreakAllCallsInModule(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakAllCallsInModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* EnableBreakAllCallsInModule(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DisableBreakAllCallsInModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DisableBreakAllCallsInModule() {
      ::grpc::Service::MarkMethodRawCallback(3,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DisableBreakAllCallsInModule(context, request, response); }));
    }
    ~WithRawCallbackMethod_DisableBreakAllCallsInModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableBreakAllCallsInModule(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakAllCallsInModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DisableBreakAllCallsInModule(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_EnableBreakCallByAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_EnableBreakCallByAddress() {
      ::grpc::Service::MarkMethodRawCallback(4,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EnableBreakCallByAddress(context, request, response); }));
    }
    ~WithRawCallbackMethod_EnableBreakCallByAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBreakCallByAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakCallByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* EnableBreakCallByAddress(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DisableBreakCallByAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DisableBreakCallByAddress() {
      ::grpc::Service::MarkMethodRawCallback(5,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DisableBreakCallByAddress(context, request, response); }));
    }
    ~WithRawCallbackMethod_DisableBreakCallByAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableBreakCallByAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakCallByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DisableBreakCallByAddress(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_EnableBreakCallByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_EnableBreakCallByName() {
      ::grpc::Service::MarkMethodRawCallback(6,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EnableBreakCallByName(context, request, response); }));
    }
    ~WithRawCallbackMethod_EnableBreakCallByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBreakCallByName(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakCallByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* EnableBreakCallByName(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DisableBreakCallByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DisableBreakCallByName() {
      ::grpc::Service::MarkMethodRawCallback(7,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DisableBreakCallByName(context, request, response); }));
    }
    ~WithRawCallbackMethod_DisableBreakCallByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableBreakCallByName(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakCallByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DisableBreakCallByName(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_EnableBreakpointByAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_EnableBreakpointByAddress() {
      ::grpc::Service::MarkMethodRawCallback(8,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EnableBreakpointByAddress(context, request, response); }));
    }
    ~WithRawCallbackMethod_EnableBreakpointByAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBreakpointByAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakpointByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* EnableBreakpointByAddress(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DisableBreakpointByAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DisableBreakpointByAddress() {
      ::grpc::Service::MarkMethodRawCallback(9,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DisableBreakpointByAddress(context, request, response); }));
    }
    ~WithRawCallbackMethod_DisableBreakpointByAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableBreakpointByAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakpointByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DisableBreakpointByAddress(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_EnableBreakpointByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_EnableBreakpointByName() {
      ::grpc::Service::MarkMethodRawCallback(10,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EnableBreakpointByName(context, request, response); }));
    }
    ~WithRawCallbackMethod_EnableBreakpointByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableBreakpointByName(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakpointByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* EnableBreakpointByName(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DisableBreakpointByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DisableBreakpointByName() {
      ::grpc::Service::MarkMethodRawCallback(11,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DisableBreakpointByName(context, request, response); }));
    }
    ~WithRawCallbackMethod_DisableBreakpointByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableBreakpointByName(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakpointByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DisableBreakpointByName(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DisassembleAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DisassembleAddress() {
      ::grpc::Service::MarkMethodRawCallback(12,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DisassembleAddress(context, request, response); }));
    }
    ~WithRawCallbackMethod_DisassembleAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisassembleAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisassembleAddressRequest* /*request*/, ::TED::Grpc::DisassembleAddressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DisassembleAddress(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_LoadModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_LoadModule() {
      ::grpc::Service::MarkMethodRawCallback(13,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->LoadModule(context, request, response); }));
    }
    ~WithRawCallbackMethod_LoadModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status LoadModule(::grpc::ServerContext* /*context*/, const ::TED::Grpc::LoadModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* LoadModule(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_UnloadModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_UnloadModule() {
      ::grpc::Service::MarkMethodRawCallback(14,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->UnloadModule(context, request, response); }));
    }
    ~WithRawCallbackMethod_UnloadModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status UnloadModule(::grpc::ServerContext* /*context*/, const ::TED::Grpc::UnloadModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* UnloadModule(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_ReadMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_ReadMemory() {
      ::grpc::Service::MarkMethodRawCallback(15,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->ReadMemory(context, request, response); }));
    }
    ~WithRawCallbackMethod_ReadMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status ReadMemory(::grpc::ServerContext* /*context*/, const ::TED::Grpc::ReadMemoryRequest* /*request*/, ::TED::Grpc::ReadMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* ReadMemory(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_WriteMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_WriteMemory() {
      ::grpc::Service::MarkMethodRawCallback(16,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->WriteMemory(context, request, response); }));
    }
    ~WithRawCallbackMethod_WriteMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status WriteMemory(::grpc::ServerContext* /*context*/, const ::TED::Grpc::WriteMemoryRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* WriteMemory(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_CreateConsole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_CreateConsole() {
      ::grpc::Service::MarkMethodRawCallback(17,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->CreateConsole(context, request, response); }));
    }
    ~WithRawCallbackMethod_CreateConsole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status CreateConsole(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* CreateConsole(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DestroyConsole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DestroyConsole() {
      ::grpc::Service::MarkMethodRawCallback(18,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DestroyConsole(context, request, response); }));
    }
    ~WithRawCallbackMethod_DestroyConsole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DestroyConsole(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DestroyConsole(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_EnableInternalLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_EnableInternalLogging() {
      ::grpc::Service::MarkMethodRawCallback(19,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->EnableInternalLogging(context, request, response); }));
    }
    ~WithRawCallbackMethod_EnableInternalLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status EnableInternalLogging(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* EnableInternalLogging(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_DisableInternalLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_DisableInternalLogging() {
      ::grpc::Service::MarkMethodRawCallback(20,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->DisableInternalLogging(context, request, response); }));
    }
    ~WithRawCallbackMethod_DisableInternalLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status DisableInternalLogging(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* DisableInternalLogging(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_Options : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_Options() {
      ::grpc::Service::MarkMethodRawCallback(21,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->Options(context, request, response); }));
    }
    ~WithRawCallbackMethod_Options() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status Options(::grpc::ServerContext* /*context*/, const ::TED::Grpc::OptionsRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* Options(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithRawCallbackMethod_TestFunction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithRawCallbackMethod_TestFunction() {
      ::grpc::Service::MarkMethodRawCallback(22,
          new ::grpc::internal::CallbackUnaryHandler< ::grpc::ByteBuffer, ::grpc::ByteBuffer>(
            [this](
                   ::grpc::CallbackServerContext* context, const ::grpc::ByteBuffer* request, ::grpc::ByteBuffer* response) { return this->TestFunction(context, request, response); }));
    }
    ~WithRawCallbackMethod_TestFunction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable synchronous version of this method
    ::grpc::Status TestFunction(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    virtual ::grpc::ServerUnaryReactor* TestFunction(
      ::grpc::CallbackServerContext* /*context*/, const ::grpc::ByteBuffer* /*request*/, ::grpc::ByteBuffer* /*response*/)  { return nullptr; }
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_GetModules : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_GetModules() {
      ::grpc::Service::MarkMethodStreamed(1,
        new ::grpc::internal::StreamedUnaryHandler<
          ::TED::Grpc::Empty, ::TED::Grpc::GetModulesResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::TED::Grpc::Empty, ::TED::Grpc::GetModulesResponse>* streamer) {
                       return this->StreamedGetModules(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_GetModules() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetModules(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GetModulesResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedGetModules(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::TED::Grpc::Empty,::TED::Grpc::GetModulesResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EnableBreakAllCallsInModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EnableBreakAllCallsInModule() {
      ::grpc::Service::MarkMethodStreamed(2,
        new ::grpc::internal::StreamedUnaryHandler<
          ::TED::Grpc::EnableBreakAllCallsInModuleRequest, ::TED::Grpc::GenericResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::TED::Grpc::EnableBreakAllCallsInModuleRequest, ::TED::Grpc::GenericResponse>* streamer) {
                       return this->StreamedEnableBreakAllCallsInModule(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_EnableBreakAllCallsInModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EnableBreakAllCallsInModule(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakAllCallsInModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEnableBreakAllCallsInModule(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::TED::Grpc::EnableBreakAllCallsInModuleRequest,::TED::Grpc::GenericResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DisableBreakAllCallsInModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DisableBreakAllCallsInModule() {
      ::grpc::Service::MarkMethodStreamed(3,
        new ::grpc::internal::StreamedUnaryHandler<
          ::TED::Grpc::DisableBreakAllCallsInModuleRequest, ::TED::Grpc::GenericResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::TED::Grpc::DisableBreakAllCallsInModuleRequest, ::TED::Grpc::GenericResponse>* streamer) {
                       return this->StreamedDisableBreakAllCallsInModule(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DisableBreakAllCallsInModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DisableBreakAllCallsInModule(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakAllCallsInModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDisableBreakAllCallsInModule(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::TED::Grpc::DisableBreakAllCallsInModuleRequest,::TED::Grpc::GenericResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EnableBreakCallByAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EnableBreakCallByAddress() {
      ::grpc::Service::MarkMethodStreamed(4,
        new ::grpc::internal::StreamedUnaryHandler<
          ::TED::Grpc::EnableBreakCallByAddressRequest, ::TED::Grpc::GenericResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::TED::Grpc::EnableBreakCallByAddressRequest, ::TED::Grpc::GenericResponse>* streamer) {
                       return this->StreamedEnableBreakCallByAddress(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_EnableBreakCallByAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EnableBreakCallByAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakCallByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEnableBreakCallByAddress(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::TED::Grpc::EnableBreakCallByAddressRequest,::TED::Grpc::GenericResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DisableBreakCallByAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DisableBreakCallByAddress() {
      ::grpc::Service::MarkMethodStreamed(5,
        new ::grpc::internal::StreamedUnaryHandler<
          ::TED::Grpc::DisableBreakCallByAddressRequest, ::TED::Grpc::GenericResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::TED::Grpc::DisableBreakCallByAddressRequest, ::TED::Grpc::GenericResponse>* streamer) {
                       return this->StreamedDisableBreakCallByAddress(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DisableBreakCallByAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DisableBreakCallByAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakCallByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDisableBreakCallByAddress(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::TED::Grpc::DisableBreakCallByAddressRequest,::TED::Grpc::GenericResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EnableBreakCallByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EnableBreakCallByName() {
      ::grpc::Service::MarkMethodStreamed(6,
        new ::grpc::internal::StreamedUnaryHandler<
          ::TED::Grpc::EnableBreakCallByNameRequest, ::TED::Grpc::GenericResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::TED::Grpc::EnableBreakCallByNameRequest, ::TED::Grpc::GenericResponse>* streamer) {
                       return this->StreamedEnableBreakCallByName(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_EnableBreakCallByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EnableBreakCallByName(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakCallByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEnableBreakCallByName(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::TED::Grpc::EnableBreakCallByNameRequest,::TED::Grpc::GenericResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DisableBreakCallByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DisableBreakCallByName() {
      ::grpc::Service::MarkMethodStreamed(7,
        new ::grpc::internal::StreamedUnaryHandler<
          ::TED::Grpc::DisableBreakCallByNameRequest, ::TED::Grpc::GenericResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::TED::Grpc::DisableBreakCallByNameRequest, ::TED::Grpc::GenericResponse>* streamer) {
                       return this->StreamedDisableBreakCallByName(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DisableBreakCallByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DisableBreakCallByName(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakCallByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDisableBreakCallByName(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::TED::Grpc::DisableBreakCallByNameRequest,::TED::Grpc::GenericResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EnableBreakpointByAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EnableBreakpointByAddress() {
      ::grpc::Service::MarkMethodStreamed(8,
        new ::grpc::internal::StreamedUnaryHandler<
          ::TED::Grpc::EnableBreakpointByAddressRequest, ::TED::Grpc::GenericResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::TED::Grpc::EnableBreakpointByAddressRequest, ::TED::Grpc::GenericResponse>* streamer) {
                       return this->StreamedEnableBreakpointByAddress(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_EnableBreakpointByAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EnableBreakpointByAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakpointByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEnableBreakpointByAddress(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::TED::Grpc::EnableBreakpointByAddressRequest,::TED::Grpc::GenericResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DisableBreakpointByAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DisableBreakpointByAddress() {
      ::grpc::Service::MarkMethodStreamed(9,
        new ::grpc::internal::StreamedUnaryHandler<
          ::TED::Grpc::DisableBreakpointByAddressRequest, ::TED::Grpc::GenericResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::TED::Grpc::DisableBreakpointByAddressRequest, ::TED::Grpc::GenericResponse>* streamer) {
                       return this->StreamedDisableBreakpointByAddress(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DisableBreakpointByAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DisableBreakpointByAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakpointByAddressRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDisableBreakpointByAddress(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::TED::Grpc::DisableBreakpointByAddressRequest,::TED::Grpc::GenericResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EnableBreakpointByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EnableBreakpointByName() {
      ::grpc::Service::MarkMethodStreamed(10,
        new ::grpc::internal::StreamedUnaryHandler<
          ::TED::Grpc::EnableBreakpointByNameRequest, ::TED::Grpc::GenericResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::TED::Grpc::EnableBreakpointByNameRequest, ::TED::Grpc::GenericResponse>* streamer) {
                       return this->StreamedEnableBreakpointByName(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_EnableBreakpointByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EnableBreakpointByName(::grpc::ServerContext* /*context*/, const ::TED::Grpc::EnableBreakpointByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEnableBreakpointByName(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::TED::Grpc::EnableBreakpointByNameRequest,::TED::Grpc::GenericResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DisableBreakpointByName : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DisableBreakpointByName() {
      ::grpc::Service::MarkMethodStreamed(11,
        new ::grpc::internal::StreamedUnaryHandler<
          ::TED::Grpc::DisableBreakpointByNameRequest, ::TED::Grpc::GenericResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::TED::Grpc::DisableBreakpointByNameRequest, ::TED::Grpc::GenericResponse>* streamer) {
                       return this->StreamedDisableBreakpointByName(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DisableBreakpointByName() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DisableBreakpointByName(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisableBreakpointByNameRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDisableBreakpointByName(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::TED::Grpc::DisableBreakpointByNameRequest,::TED::Grpc::GenericResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DisassembleAddress : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DisassembleAddress() {
      ::grpc::Service::MarkMethodStreamed(12,
        new ::grpc::internal::StreamedUnaryHandler<
          ::TED::Grpc::DisassembleAddressRequest, ::TED::Grpc::DisassembleAddressResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::TED::Grpc::DisassembleAddressRequest, ::TED::Grpc::DisassembleAddressResponse>* streamer) {
                       return this->StreamedDisassembleAddress(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DisassembleAddress() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DisassembleAddress(::grpc::ServerContext* /*context*/, const ::TED::Grpc::DisassembleAddressRequest* /*request*/, ::TED::Grpc::DisassembleAddressResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDisassembleAddress(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::TED::Grpc::DisassembleAddressRequest,::TED::Grpc::DisassembleAddressResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_LoadModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_LoadModule() {
      ::grpc::Service::MarkMethodStreamed(13,
        new ::grpc::internal::StreamedUnaryHandler<
          ::TED::Grpc::LoadModuleRequest, ::TED::Grpc::GenericResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::TED::Grpc::LoadModuleRequest, ::TED::Grpc::GenericResponse>* streamer) {
                       return this->StreamedLoadModule(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_LoadModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status LoadModule(::grpc::ServerContext* /*context*/, const ::TED::Grpc::LoadModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedLoadModule(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::TED::Grpc::LoadModuleRequest,::TED::Grpc::GenericResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_UnloadModule : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_UnloadModule() {
      ::grpc::Service::MarkMethodStreamed(14,
        new ::grpc::internal::StreamedUnaryHandler<
          ::TED::Grpc::UnloadModuleRequest, ::TED::Grpc::GenericResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::TED::Grpc::UnloadModuleRequest, ::TED::Grpc::GenericResponse>* streamer) {
                       return this->StreamedUnloadModule(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_UnloadModule() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status UnloadModule(::grpc::ServerContext* /*context*/, const ::TED::Grpc::UnloadModuleRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedUnloadModule(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::TED::Grpc::UnloadModuleRequest,::TED::Grpc::GenericResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_ReadMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_ReadMemory() {
      ::grpc::Service::MarkMethodStreamed(15,
        new ::grpc::internal::StreamedUnaryHandler<
          ::TED::Grpc::ReadMemoryRequest, ::TED::Grpc::ReadMemoryResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::TED::Grpc::ReadMemoryRequest, ::TED::Grpc::ReadMemoryResponse>* streamer) {
                       return this->StreamedReadMemory(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_ReadMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status ReadMemory(::grpc::ServerContext* /*context*/, const ::TED::Grpc::ReadMemoryRequest* /*request*/, ::TED::Grpc::ReadMemoryResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedReadMemory(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::TED::Grpc::ReadMemoryRequest,::TED::Grpc::ReadMemoryResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_WriteMemory : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_WriteMemory() {
      ::grpc::Service::MarkMethodStreamed(16,
        new ::grpc::internal::StreamedUnaryHandler<
          ::TED::Grpc::WriteMemoryRequest, ::TED::Grpc::GenericResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::TED::Grpc::WriteMemoryRequest, ::TED::Grpc::GenericResponse>* streamer) {
                       return this->StreamedWriteMemory(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_WriteMemory() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status WriteMemory(::grpc::ServerContext* /*context*/, const ::TED::Grpc::WriteMemoryRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedWriteMemory(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::TED::Grpc::WriteMemoryRequest,::TED::Grpc::GenericResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_CreateConsole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_CreateConsole() {
      ::grpc::Service::MarkMethodStreamed(17,
        new ::grpc::internal::StreamedUnaryHandler<
          ::TED::Grpc::Empty, ::TED::Grpc::GenericResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::TED::Grpc::Empty, ::TED::Grpc::GenericResponse>* streamer) {
                       return this->StreamedCreateConsole(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_CreateConsole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status CreateConsole(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedCreateConsole(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::TED::Grpc::Empty,::TED::Grpc::GenericResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DestroyConsole : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DestroyConsole() {
      ::grpc::Service::MarkMethodStreamed(18,
        new ::grpc::internal::StreamedUnaryHandler<
          ::TED::Grpc::Empty, ::TED::Grpc::GenericResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::TED::Grpc::Empty, ::TED::Grpc::GenericResponse>* streamer) {
                       return this->StreamedDestroyConsole(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DestroyConsole() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DestroyConsole(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDestroyConsole(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::TED::Grpc::Empty,::TED::Grpc::GenericResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_EnableInternalLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_EnableInternalLogging() {
      ::grpc::Service::MarkMethodStreamed(19,
        new ::grpc::internal::StreamedUnaryHandler<
          ::TED::Grpc::Empty, ::TED::Grpc::GenericResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::TED::Grpc::Empty, ::TED::Grpc::GenericResponse>* streamer) {
                       return this->StreamedEnableInternalLogging(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_EnableInternalLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status EnableInternalLogging(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedEnableInternalLogging(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::TED::Grpc::Empty,::TED::Grpc::GenericResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_DisableInternalLogging : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_DisableInternalLogging() {
      ::grpc::Service::MarkMethodStreamed(20,
        new ::grpc::internal::StreamedUnaryHandler<
          ::TED::Grpc::Empty, ::TED::Grpc::GenericResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::TED::Grpc::Empty, ::TED::Grpc::GenericResponse>* streamer) {
                       return this->StreamedDisableInternalLogging(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_DisableInternalLogging() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status DisableInternalLogging(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedDisableInternalLogging(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::TED::Grpc::Empty,::TED::Grpc::GenericResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_Options : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_Options() {
      ::grpc::Service::MarkMethodStreamed(21,
        new ::grpc::internal::StreamedUnaryHandler<
          ::TED::Grpc::OptionsRequest, ::TED::Grpc::GenericResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::TED::Grpc::OptionsRequest, ::TED::Grpc::GenericResponse>* streamer) {
                       return this->StreamedOptions(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_Options() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status Options(::grpc::ServerContext* /*context*/, const ::TED::Grpc::OptionsRequest* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedOptions(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::TED::Grpc::OptionsRequest,::TED::Grpc::GenericResponse>* server_unary_streamer) = 0;
  };
  template <class BaseClass>
  class WithStreamedUnaryMethod_TestFunction : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithStreamedUnaryMethod_TestFunction() {
      ::grpc::Service::MarkMethodStreamed(22,
        new ::grpc::internal::StreamedUnaryHandler<
          ::TED::Grpc::Empty, ::TED::Grpc::GenericResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerUnaryStreamer<
                     ::TED::Grpc::Empty, ::TED::Grpc::GenericResponse>* streamer) {
                       return this->StreamedTestFunction(context,
                         streamer);
                  }));
    }
    ~WithStreamedUnaryMethod_TestFunction() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status TestFunction(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::TED::Grpc::GenericResponse* /*response*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with streamed unary
    virtual ::grpc::Status StreamedTestFunction(::grpc::ServerContext* context, ::grpc::ServerUnaryStreamer< ::TED::Grpc::Empty,::TED::Grpc::GenericResponse>* server_unary_streamer) = 0;
  };
  typedef WithStreamedUnaryMethod_GetModules<WithStreamedUnaryMethod_EnableBreakAllCallsInModule<WithStreamedUnaryMethod_DisableBreakAllCallsInModule<WithStreamedUnaryMethod_EnableBreakCallByAddress<WithStreamedUnaryMethod_DisableBreakCallByAddress<WithStreamedUnaryMethod_EnableBreakCallByName<WithStreamedUnaryMethod_DisableBreakCallByName<WithStreamedUnaryMethod_EnableBreakpointByAddress<WithStreamedUnaryMethod_DisableBreakpointByAddress<WithStreamedUnaryMethod_EnableBreakpointByName<WithStreamedUnaryMethod_DisableBreakpointByName<WithStreamedUnaryMethod_DisassembleAddress<WithStreamedUnaryMethod_LoadModule<WithStreamedUnaryMethod_UnloadModule<WithStreamedUnaryMethod_ReadMemory<WithStreamedUnaryMethod_WriteMemory<WithStreamedUnaryMethod_CreateConsole<WithStreamedUnaryMethod_DestroyConsole<WithStreamedUnaryMethod_EnableInternalLogging<WithStreamedUnaryMethod_DisableInternalLogging<WithStreamedUnaryMethod_Options<WithStreamedUnaryMethod_TestFunction<Service > > > > > > > > > > > > > > > > > > > > > > StreamedUnaryService;
  template <class BaseClass>
  class WithSplitStreamingMethod_GetBreakpoints : public BaseClass {
   private:
    void BaseClassMustBeDerivedFromService(const Service* /*service*/) {}
   public:
    WithSplitStreamingMethod_GetBreakpoints() {
      ::grpc::Service::MarkMethodStreamed(0,
        new ::grpc::internal::SplitServerStreamingHandler<
          ::TED::Grpc::Empty, ::TED::Grpc::BreakpointResponse>(
            [this](::grpc::ServerContext* context,
                   ::grpc::ServerSplitStreamer<
                     ::TED::Grpc::Empty, ::TED::Grpc::BreakpointResponse>* streamer) {
                       return this->StreamedGetBreakpoints(context,
                         streamer);
                  }));
    }
    ~WithSplitStreamingMethod_GetBreakpoints() override {
      BaseClassMustBeDerivedFromService(this);
    }
    // disable regular version of this method
    ::grpc::Status GetBreakpoints(::grpc::ServerContext* /*context*/, const ::TED::Grpc::Empty* /*request*/, ::grpc::ServerWriter< ::TED::Grpc::BreakpointResponse>* /*writer*/) override {
      abort();
      return ::grpc::Status(::grpc::StatusCode::UNIMPLEMENTED, "");
    }
    // replace default version of method with split streamed
    virtual ::grpc::Status StreamedGetBreakpoints(::grpc::ServerContext* context, ::grpc::ServerSplitStreamer< ::TED::Grpc::Empty,::TED::Grpc::BreakpointResponse>* server_split_streamer) = 0;
  };
  typedef WithSplitStreamingMethod_GetBreakpoints<Service > SplitStreamedService;
  typedef WithSplitStreamingMethod_GetBreakpoints<WithStreamedUnaryMethod_GetModules<WithStreamedUnaryMethod_EnableBreakAllCallsInModule<WithStreamedUnaryMethod_DisableBreakAllCallsInModule<WithStreamedUnaryMethod_EnableBreakCallByAddress<WithStreamedUnaryMethod_DisableBreakCallByAddress<WithStreamedUnaryMethod_EnableBreakCallByName<WithStreamedUnaryMethod_DisableBreakCallByName<WithStreamedUnaryMethod_EnableBreakpointByAddress<WithStreamedUnaryMethod_DisableBreakpointByAddress<WithStreamedUnaryMethod_EnableBreakpointByName<WithStreamedUnaryMethod_DisableBreakpointByName<WithStreamedUnaryMethod_DisassembleAddress<WithStreamedUnaryMethod_LoadModule<WithStreamedUnaryMethod_UnloadModule<WithStreamedUnaryMethod_ReadMemory<WithStreamedUnaryMethod_WriteMemory<WithStreamedUnaryMethod_CreateConsole<WithStreamedUnaryMethod_DestroyConsole<WithStreamedUnaryMethod_EnableInternalLogging<WithStreamedUnaryMethod_DisableInternalLogging<WithStreamedUnaryMethod_Options<WithStreamedUnaryMethod_TestFunction<Service > > > > > > > > > > > > > > > > > > > > > > > StreamedService;
};

}  // namespace Grpc
}  // namespace TED


#endif  // GRPC_TED_2eproto__INCLUDED
